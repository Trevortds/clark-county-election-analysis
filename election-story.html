<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Law of Large Numbers: Understanding Election Statistics</title>
    
    <!-- Dependencies -->
    <script src="https://unpkg.com/scrollama@3.2.0/build/scrollama.min.js"></script>
    
    <style>
        :root {
            /* Color palette */
            --olivine: #a1c489ff;
            --cadet-gray: #96a3a6ff;
            --dark-spring-green: #33774eff;
            --gunmetal: #213231ff;
            --auburn: #9e2a2bff;
            
            /* Derived colors */
            --bg-dark: #26302d;
            --bg-light: #fafafa;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --text-light: #e0e0e0;
            --accent: var(--dark-spring-green);
            --highlight: var(--olivine);
        }
        
        /* Coin Flip Animation Styles */
        @keyframes flip-to-heads {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(1800deg); }
        }
        
        @keyframes flip-to-tails {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(1980deg); }
        }
        
        .coin-container {
            width: 100px;
            height: 100px;
            perspective: 1000px;
            margin: 20px auto;
        }
        
        .coin {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            cursor: pointer;
        }
        
        .coin-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            backface-visibility: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .heads {
            background: var(--olivine);
            color: var(--gunmetal);
        }
        
        .tails {
            background: var(--dark-spring-green);
            color: white;
            transform: rotateY(180deg);
        }
        
        /* Multi-coin grid */
        .coins-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 240px;
            margin: 20px auto;
        }
        
        /* Multi-coin grid */
        .ten-coins-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            max-width: 565px;
            margin: 20px auto;
        }
        
        .coins-grid .coin-container {
            width: 80px;
            height: 80px;
        }
        
        .coins-grid .coin-face {
            font-size: 18px;
        }
        
        /* Viz-specific buttons */
        .viz-button {
            background: var(--dark-spring-green);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .viz-button:hover {
            background: var(--gunmetal);
        }
        
        .viz-result {
            margin-top: 20px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(161, 196, 137, 0.2);
            border-radius: 6px;
            min-height: 50px;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Source Sans Pro', sans-serif;
            background: var(--bg-light);
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 18px;
        }
        
        /* Main layout grid */
        .main-container {
            display: grid;
            grid-template-columns: 170px 1fr 280px;
            max-width: 1440px;
            margin: 0 auto;
            gap: 40px;
            padding: 40px 20px;
            min-height: 100vh;
        }
        
        /* Left navigation (table of contents) */
        .toc-sidebar {
            position: sticky;
            top: 40px;
            height: fit-content;
            padding: 0;
        }
        
        .toc-sidebar h3 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            margin: 0 0 20px 0;
            font-weight: 600;
        }
        
        .toc-sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .toc-sidebar li {
            margin: 0;
        }
        
        .toc-sidebar a {
            display: block;
            padding: 8px 16px 8px 20px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 15px;
            border-left: 3px solid transparent;
            margin-left: -20px;
            transition: all 0.2s ease;
        }
        
        .toc-sidebar a:hover {
            color: var(--text-primary);
            background: rgba(0,0,0,0.02);
        }
        
        .toc-sidebar a.active {
            color: var(--accent);
            border-left-color: var(--accent);
            background: rgba(51, 119, 78, 0.05);
            font-weight: 600;
        }
        
        /* Main content area */
        .article-content {
            max-width: 700px;
            margin: 0 auto;
        }
        
        .article-content h1 {
            font-size: 48px;
            line-height: 1.2;
            margin: 0 0 16px 0;
            font-weight: 700;
            color: var(--gunmetal);
        }
        
        .article-content .subtitle {
            font-size: 22px;
            color: var(--text-secondary);
            margin: 0 0 60px 0;
            font-weight: 400;
        }
        
        .article-content p {
            margin: 0 0 28px 0;
            color: var(--text-primary);
        }
        
        .article-content p.lead {
            font-size: 21px;
            line-height: 1.6;
            color: var(--text-primary);
            font-weight: 400;
        }
        
        /* Right sidebar */
        .right-sidebar {
            position: sticky;
            top: 40px;
            align-self: flex-start;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            /* Hide scrollbar but keep functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        .right-sidebar::-webkit-scrollbar {
            display: none;
        }
        
        .controls-section {
            background: white;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .controls-section h4 {
            margin: 0 0 16px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }
        
        /* Footnotes container - flows below controls */
        #footnotes-container {
            /* Remove sticky positioning to prevent overlap */
            margin-top: 24px;
        }
        
        /* Footnotes in right sidebar */
        .footnote {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-secondary);
            background: rgba(161, 196, 137, 0.08);
            border-left: 3px solid var(--olivine);
            border-radius: 4px;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            max-height: 0;
            overflow: hidden;
            margin-bottom: 0;
            padding: 0 16px;
        }
        
        .footnote.visible {
            opacity: 1;
            transform: translateY(0);
            max-height: 500px; /* Increased to accommodate longer footnotes */
            padding: 16px;
            margin-bottom: 16px;
        }
        
        /* Visualization containers */
        .viz-container {
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 48px;
            margin: 32px -20px;
            position: relative;
        }
        
        .viz-container .viz-placeholder {
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--cadet-gray);
            font-style: italic;
            border: 2px dashed rgba(161, 196, 137, 0.3);
            border-radius: 4px;
        }

        .plot-container {
            width: 100%;
            max-width: 100%;
            margin: 20px auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background-color: white;
        }
        
        /* Light container for graph visualizations */
        .viz-container-light {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 32px 0px;
            margin: 32px -20px;
            position: relative;
        }
        
        .viz-container-light h3 {
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Image container styling */
        .image-container {
            width: 100%;
            max-width: 700px;
            margin: 32px auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: white;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .image-grid .image-container {
            max-width: 100%;
        }
        
        .image-container:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }
        
        .image-container img {
            width: 100%;
            height: auto;
            padding: 10px;
            display: block;
        }
        
        /* Image grid for side-by-side display */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 32px -40px;
            max-width: 900px;
            width: calc(100% + 80px);
        }
        
        .image-grid .image-container {
            margin: 0;
        }
        
        /* Responsive adjustment for small screens */
        @media (max-width: 600px) {
            .image-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Coin games specific slider styling */
        .coin-games-controls {
            width: 100%;
            max-width: 100%;
            margin: 20px auto 0;
        }
        
        .coin-games-controls .slider-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0;
        }
        
        .coin-games-controls label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        .coin-games-controls input[type="range"] {
            flex: 1;
            margin: 0 16px;
        }
        
        .coin-games-controls .value {
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }
        
        /* Sliders and controls */
        .slider-control {
            margin-bottom: 24px;
        }
        
        .slider-control label {
            display: block;
            font-size: 14px;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .slider-control input[type="range"] {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--dark-spring-green);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-control .value {
            float: right;
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
        }
        
        /* Mobile Controls Bubble */
        .mobile-controls-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--auburn);
            border-radius: 50%;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .mobile-controls-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }
        
        .mobile-controls-toggle svg {
            width: 30px;
            height: 30px;
            fill: white;
        }
        
        /* Mobile overlay for sidebar */
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .mobile-overlay.active {
            opacity: 1;
        }
        
        /* Close button for mobile */
        .mobile-close {
            display: none;
        }
        
        /* Responsive adjustments */
        @media (max-width: 968px) {
            /* Adjust main grid for tablet/mobile */
            .main-container {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px 15px;
            }
            
            /* Hide sidebars on mobile */
            .toc-sidebar,
            .right-sidebar {
                display: none;
            }
            
            /* Show mobile controls toggle */
            .mobile-controls-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Transform right sidebar into mobile panel */
            .right-sidebar.mobile-active {
                display: block;
                position: fixed;
                right: 0;
                top: 0;
                height: 100vh;
                width: 300px;
                max-width: 85vw;
                background: white;
                z-index: 1001;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                box-shadow: -4px 0 16px rgba(0,0,0,0.1);
                padding: 60px 20px 20px;
                overflow-y: auto;
            }
            
            .right-sidebar.mobile-active.open {
                transform: translateX(0);
            }
            
            /* Show close button on mobile */
            .mobile-close {
                display: block;
                position: absolute;
                top: 15px;
                right: 15px;
                width: 32px;
                height: 32px;
                background: none;
                border: none;
                cursor: pointer;
                padding: 0;
                z-index: 1002;
            }
            
            .mobile-close svg {
                width: 24px;
                height: 24px;
                fill: var(--text-secondary);
            }
            
            /* Full width containers on mobile */
            .viz-container,
            .viz-container-light {
                margin: 20px -15px;
                border-radius: 0;
                padding: 32px 15px;
            }
            
            /* Adjust article content */
            .article-content {
                padding: 0;
            }
            
            .article-content h1 {
                font-size: 36px;
            }
            
            .article-content h2 {
                font-size: 28px;
            }
            
            /* Show overlay on mobile */
            .mobile-overlay {
                display: block;
            }
            
            /* Mobile-specific text */
            .desktop-only {
                display: none;
            }
            
            .mobile-only {
                display: block !important;
            }
        }
        
        /* Desktop-specific text */
        @media screen and (min-width: 969px) {
            .mobile-only {
                display: none !important;
            }
            
            .desktop-only {
                display: block;
            }
        }
        
        /* Toggle Switch Styling */
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #ff3b30;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
    </style>
    
    <!-- Scrollama library -->
    <script src="https://unpkg.com/scrollama"></script>
</head>
<body>
    <div class="main-container">
        <!-- Left sidebar: Table of Contents -->
        <nav class="toc-sidebar">
            <h3>Contents</h3>
            <ul>
                <li><a href="#intro" class="active">Introduction</a></li>
                <li><a href="#coin-flip">The Coin Flip Game</a></li>
                <li><a href="#law-of-large">Law of Large Numbers</a></li>
                <li><a href="#election-data">Election Data Analysis</a></li>
                <li><a href="#smoking-gun">The "Smoking Gun"</a></li>
                <li><a href="#conclusion">Conclusion</a></li>
            </ul>
        </nav>
        
        <!-- Main content area -->
        <article class="article-content">
            <h1>The Fraud Behind 2024 Election Fraud Claims</h1>
            <p class="subtitle">How the Election Truth Alliance misunderstood Stats 101, decieved themselves, and created a new conspiracy subculture</p>
            
            <section id="coin-flip">
                <h2> Let's play a game </h2>
                <p> You flip a coin, I'll call it. </p>
            </section>  
          
            <!-- First Visualization: Single Coin -->
            <div class="viz-container" id="single-coin-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Single Coin Flip</h3>
                <div class="coin-container" data-viz="single">
                    <div class="coin">
                        <div class="coin-face heads">H</div>
                        <div class="coin-face tails">T</div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="single">Flip the Coin!</button>
                    <div class="viz-result" data-viz="single"></div>
                </div>
            </div>
            
            <section id="four-coins">
                <p>
                    Now let's make things more interesting. Instead of flipping one coin, let's flip four coins 
                    at once. Can you predict what percentage will be heads?
                </p>
                
                <p>
                    With more coins, we start to see patterns emerge. The results become more predictable, 
                    even though each individual coin flip is still random. This is the beginning of understanding 
                    the Law of Large Numbers.
                </p>
            </section>
            
            <!-- Second Visualization: Four Coins -->
            <div class="viz-container step" id="four-coins-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Four Coins</h3>
                <div class="coins-grid" data-viz="four">
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="four">Flip All Four!</button>
                    <div class="viz-result" data-viz="four"></div>
                </div>
            </div>

            <section id="ten-coins">
                <p>
                    Let's do ten coins now. How many will be heads. Put in your guess:
                </p>
            </section>

            <!-- Third Visualization: Ten Coins -->
            <div class="viz-container step" id="ten-coins-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Ten Coins</h3>
                <div class="ten-coins-grid" data-viz="ten">
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="ten">Flip All Ten!</button>
                    <div class="viz-result" data-viz="ten"></div>
                </div>
            </div>
            <section id="coin-games">
                <p>
                    I get the feeling you feel like you can win more often than you have, so 
                    I'll make it easy for you. 
                </p>
                <p>
                    I'll run 20 games at once, and put them on a chart for you, 
                    and this time you get to pick how many coins are tossed. You only need to be correct within a 10% window.
                </p>
            </section>

            <!-- Fourth Visualization: Coin Games -->
            <div class="viz-container-light step" id="coin-games-viz">
                <div id="coin-games-plot" class="plot-container"></div>
                <div class="coin-games-controls">
                    <div class="slider-control">
                        <label>Number of Flips:</label>
                        <input type="range" id="flips-slider" min="10" max="1000" value="0" step="10">
                        <span class="value" id="flips-display">10</span>
                    </div>
                    <p style="text-align: center; font-size: 14px; color: var(--text-secondary); margin-top: 8px;">Slide to change how many flips are done for each game</p>
                    <p id="win-percentage" style="text-align: center; font-size: 18px; color: var(--dark-spring-green); font-weight: 600; margin-top: 12px; opacity: 0; transition: opacity 0.3s ease-in;">Your win rate: <span id="win-rate-value">0%</span></p>
                    <p id="convergence-notice" style="text-align: center; font-size: 28px; color: var(--auburn); font-weight: bold; margin-top: 20px; display: none; opacity: 0; transition: opacity 0.5s ease-in;">Hey, wait a minute...</p>
                </div>
            </div>
            
            
            <section id="coin-game-explanation">
                <p class="lead">
                    I forgot to mention, the coins that we've been flipping prefer to land on tails. Here, you can make them fair if you want, or bias them towards you.
                </p>
                
            </section>   
            <section id="law-of-large-numbers-explanation">
                <p class="lead">
                    I did not lie to you about the outcomes of any of our prediction games, I just withheld the underlying preferences of the coins. You were able to detect those preferences by playing a large number of games with a large number of flips each. The more flips in a game, the closer the average result was to the true value of the coin. 
                </p>
                <h3>
                    What you've just experienced is the Law of Large Numbers <sup>2</sup> and it is a centerpiece of statistics. Arguably, it is why we even do statistics <strong><em>at all</em></strong>.
                </h3>
                <p>
                    The fact that variance around the mean is guaranteed to decrease as more samples are taken is critical for decision making using statistics. This is why scientists look for the largest test groups they can get their hands on for running experiments. [ maybe remove the casino thing, casinos are associated with unfairness and that's not the point. ] This is also why casinos are never afraid for their profits: even though the outcome of any individual game can be very hard to predict, and the house may frequently lose several games in a row, over the long run, the average outcome of thousands of games will converge to the "house edge", their initial likelihood of winning. 
                </p>
                <p>
                    The Law of Large Numbers tells us that the more samples we take from some hard-to-predict source, the closer the average will be to the true value we are sampling from. More samples, more consistent and accurate results. 
                </p>
            </section>
            
            
            <section id="eta-introduction-lead-in">
                <p class="lead">
                    Now we are ready to talk about Election Truth Alliance
                </p>
            </section>
            
            <section id="eta-introduction">
                <h2>Introduction</h2>
                
                <p>
                    Election Truth Alliance is self-declared Election Watchdog incorporated on January 13 2025, three-person team composed of Lilli McGregor (Canadian civil servant), Nathan Taylor ("cybersecurity specialist", works as a 25B tech support for the US Army, job description includes "connecting printers" and "resetting passwords"), and "Jive", the anonymous executive director who "envisioned and articulated the need for our organization", the only detail we know is that they are an "auditor and accountant". 
                </p>

                <p>
                    This group coalesced very shortly after the 2024 US Federal election, as early as November 13, and began preparing to publish arguments that the election was rigged at that point in time, even before much of the data that they would later be basing their work on was released. 
                </p>
                
                <p>
                    In March 2025, Election Truth Alliance debuted their proof that the 2024 US Presidential election was stolen by means of electronic vote flipping. This post will be focused on their original analysis of Clark County Nevada. 
                </p>
                
                <p>
                    Election Truth Alliance claims that Nevada vote records show that voting machines were altered to start flipping Presidential votes in favor of Trump after 250 or so votes were cast. 
                </p>
                
                <p>
                    I have reproduced their charts to confirm their methodology, and I will explain how that methodology does not show what they claim it does. I will show you what Election Truth Alliance found in the Clark County Cast Vote Records, why it looks suspicious to them, and why it is exactly what we'd expect to see.
                </p>
                
                <h3>Who am I?</h3>
                
                <p>
                    I am a person who cares deeply about election integrity, which is why misleading statistical claims concern me regardless of their source and in support of which candidate. 
                </p>
            </section>
            
            <section id="main-chart">
                <h2>The Main Chart</h2>
                
                <p>
                    Election Truth Alliance's analysis focus on this chart, which they claim is anomalous. To understand how to read this chart, keep in mind that each point is not a vote, but an entire voting machine. The numbers on the X axis are the number of votes each machine has counted, and the Y axis is Trump preference.                 </p>

                <div class="image-container">
                    <img src="images/Pasted image 20250702074913.png" alt="ETA main analysis chart showing voting machines" class="content-image">
                </div>

                <p>
                    Here's what Election Truth Alliance has to say about this chart: 
                </p>

                <p>
                    <!-- TODO pop this out into a quote block -->
                    > Expected randomness in the Early Voting results are observed **until approximately 250 ballots have been processed. Beyond that range, a visible shift is observed** once the number of ballots processed exceeds the threshold, resulting in a **high degree of clustering and unusual uniformity**, a departure from expected human voting behavior. The pattern is more distinct (closer to 60% votes for Trump, closer to 40% votes for Harris) with more ballots processed by a given voting machine.

                    > Rather than an expected distribution of votes, similar to Election Day votes, the Early Voting data suggests there may be a correlation between the quantity of ballots processed and the overall candidate vote percentage. 
                </p>

                <p>
                So, are they right? Is this data anomalous? 
                </p>
                <p>
                Clearly the machines tend to converge at around 60% Pro-Trump as the number of votes counted by each machine increases, as they say. But **is that proof of tampering**? 
                </p>
                <p>
                    To answer that for yourself, think back to the coin game we played above. If I said, "rather than showing an expected distribution of coin flips, the coin flipping games showed a correlation between the number of coin flips and the overall heads percentage", does that describe a manipulation affecting the results, or does that describe what the game naturally does when you increase the number of flips per game?
                </p>
                <p>
                    Let's go back to Election Truth Alliance for a second, because they say that these graphs are "abnormal" compared to Election Day votes. So what do Election Day votes look like? 
                </p>
                <p>
                    I have to preface this by pointing out that for some reason ETA often vertically mirrors their graphs back on themselves, switching the color to blue. They are showing the exact same data in both colors, just for the red dots, the top of the graph is Trump preference and the bottom is Harris preference, and in the blue graph it's vice-versa. It's the same data. 
                </p>
                <p>
                    So, our point of comparison is this:
                </p>
            
                <div class="image-container">
                    <img src="images/Pasted image 20250702080329.png" alt="ETA mirrored chart showing the same data in different colors" class="content-image">
                </div>

                <p>
                    And here is what Election Truth Alliance claims is a "normal" Election Day chart:
                </p>
                <div class="image-grid">
                    <div class="image-container">
                        <img src="images/Pasted image 20250702080345.png" alt="ETA normal early-voting election chart" class="content-image">
                    </div>
                    
                    <div class="image-container">
                        <img src="images/Pasted image 20250702075428.png" alt="ETA General election chart" class="content-image">
                    </div>
                </div>
                
                <p>
                    If you don't immediately see the problem here, I don't blame you, it's one of the oldest tricks in the bad-statistics book.                 </p>
            </section>
            
            <section id="x-axis-analysis">
                <h3>The X Axis</h3>
                
                <p>
                    Take a look at the X axis in these graphs. The "normal" elections max out at 800 or 100 votes per machine, but the 2024 Early Voting election has as many as 1200 votes per machine! We can't tell what the election day machines would have done if they had 1200 votes, because none of them cracked 125!                 </p>
                
                <p>
                    If we truncate the Early Voting chart so that we have an apples-to-apples comparison along the same width of X axis as the 2020 early votes...
                </p>
                <div class="image-grid">
                    <div class="image-container">
                        <img src="images/Pasted image 20250702080345.png" alt="ETA normal early-voting election chart" class="content-image">
                    </div>
                    
                    <div class="image-container">
                        <img src="images/Pasted image 20250702081653.png" alt="Truncated early voting chart for fair comparison" class="content-image">
                    </div>
                </div>

                <p>
                    They look identical! Note how both of the graphs do very clearly show a tendency to start converging in the same way.                 
                </p>
                
                <p>
                    Either the 2020 election was manipulated in the exact same way as ETA is claiming that 2024 was manipulated, or comparing these charts to each other does not prove manipulation. 
                </p>

                <p>
                    If you want to peruse the data further, here are some interactive visualizations of the 2024 Cast Vote Records, both for Early Voting and Election Day voting                
                </p>
            </section>
            
            <!-- Early Voting Scatterplot Visualization -->
            <div class="viz-container-light step" id="early-voting-scatterplot-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Early Voting Scatterplot</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="radio-container" style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; margin-right: 8px; white-space: nowrap;">Truncate Mode:</span>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="none" checkedstyle="margin-right: 4px;">
                            None
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="cutoff800" style="margin-right: 4px;">
                            < 800 votes
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="cutoff125" style="margin-right: 4px;">
                            < 125 votes
                        </label>
                    </div>
                </div>
                <div id="early-voting-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="early-voting-scatterplot" class="plot-container"></div>
            </div>
            
            <!-- Election Day Scatterplot Visualization -->
            <div class="viz-container-light step" id="election-day-scatterplot-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Day Scatterplot</h3>
                <div id="election-day-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="election-day-scatterplot" class="plot-container"></div>
            </div>
            
            <section id="machine-history">
                <h3>The Machine History</h3>
                
                <p>
                    Remember, the dots in the graphs above are <em>machines</em> not <em>votes</em>. Each dot is a machine tabulator. The analysis provided by Election Truth Alliance is not based on a time-wise analysis of the votes as they went in, but rather a guess based on the tallies that came out of machines with more or less total votes. 
                </p>

                <p>
                    However, we <em>do</em> have access to the vote data, on each machine, in the order the votes were cast. 
                </p>
                
                <p>
                    This means that we can play a history game, just like we did with the coin flips above, showing each machine's average vote as each new vote is added to it. We can watch the election play out on each machine over time, and see the running tallies as the ballots go in!                 </p>
                
                <p>
                    I have also given you the option to color the machines by their location, urban or rural. Nevada allows voters to vote at any location, so each machine at each voting site will get a mix of voters from many places, but if most of the people who used a machine live in rural precincts, we can surmise that the machine was in a rural location. Similarly if most of the votes on a machine came from voters who live in urban precincts, that machine was probably in an urban area. Machines with an even split were likely placed on the urban periphery, (perhaps near suburban shopping centers that attract people from inside and outside the city).                </p>
            </section>
            
            <!-- Machine History Visualization -->
            <div class="viz-container-light step" id="machine-history-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Machine Vote History</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Line Count:</span>
                        <div class="radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistoryLineCount" value="all" style="margin-right: 4px;">
                                All
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistoryLineCount" value="100" style="margin-right: 4px;">
                                100
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistoryLineCount" value="50" checked style="margin-right: 4px;">
                                50
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistoryLineCount" value="20" style="margin-right: 4px;">
                                20
                            </label>
                        </div>
                        <div style="font-size: 0.8em; color: #666; text-align: center; max-width: 200px;">
                            <em>Note: "All" may take time to load</em>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Selection Method:</span>
                        <div class="radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistorySelectionMethod" value="longest" checked style="margin-right: 4px;">
                                Longest
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="machineHistorySelectionMethod" value="random" style="margin-right: 4px;">
                                Random
                            </label>
                        </div>
                    </div>
                </div>
                <div id="machine-history-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="machine-history-plot" class="plot-container"></div>
            </div>
            <section id="machine-history-analysis">
                <p>
                    As you can see, every machine quickly finds its way to a stable average, and that average correlates not with the number of votes total on the machine (they don't progress upwards as the graph continues right), they level out. We know from the coin flip game above that the point they level out at is the true opinion of the group they are sampling from, which is why the vertical axis does correlate so strongly to color. Rural people were more likely to support Trump, urban people more likely to support Kamala, and suburban people, whose voting sites got a mix of both in large numbers, leaned towards Trump.                 </p>
                
                <p>
                    Okay, so what? The machines all converge to various numbers. What does this mean for our analysis?                 
                </p>
                <p>
                    Well, Election Truth Alliance's allegation is that the machines started flipping votes to maintain a certain level of Trump support starting at 200 or so votes.
                </p>
                <p>
                    So let's see if that's true. Let's run time backwards. 
                </p>
                
                <p>
                    The next visualization will show the voting history of each machine *as if* the ballots were inserted in the opposite order, from last to first.                 </p>
                
                <p>
                    If Election Truth Alliance is correct, we would see something like this, where starting from the last vote cast and working backwards in time to the first vote, each machine will show a solid line of "manipulated" votes, and then when they hit the magical 250-votes-left threshold when they suddenly bloom out to a variety of "true" vote counts.                 </p>
                
                <div class="image-container">
                    <img src="images/Reversed_voting_game_history.png" alt="Hypothetical reversed voting history if ETA was correct" class="content-image">
                </div>
                
                <p>
                    Instead what we see is this:
                </p>
            </section>
            
            <!-- Reversed Game History Visualization -->
            <div class="viz-container-light step" id="reversed-game-history-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Reversed Voting History</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Line Count:</span>
                        <div class="radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryLineCount" value="all" style="margin-right: 4px;">
                                All
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryLineCount" value="100" style="margin-right: 4px;">
                                100
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryLineCount" value="50" checked style="margin-right: 4px;">
                                50
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryLineCount" value="20" style="margin-right: 4px;">
                                20
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Selection Method:</span>
                        <div class="radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistorySelectionMethod" value="longest" checked style="margin-right: 4px;">
                                Longest
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistorySelectionMethod" value="random" style="margin-right: 4px;">
                                Random
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Direction:</span>
                        <div class="radio-group" style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryTimeDirection" value="reverse" checked style="margin-right: 4px;">
                                Backward
                            </label>
                            <label style="white-space: nowrap; font-size: 0.9em; cursor: pointer;">
                                <input type="radio" name="reversedHistoryTimeDirection" value="forward" style="margin-right: 4px;">
                                Forward
                            </label>
                        </div>
                    </div>
                </div>
                <div id="reversed-game-history-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="reversed-game-history-plot" class="plot-container"></div>
            </div>
            
            <section id="reversed-game-analysis">
                <p>
                    It looks the same!
                </p>

                <p class="lead">
                    <!-- TODO emphasize this more -->
                    Because this isn't what fraud looks like, this is what counting looks like.
                </p>
            </section>
            
            <section id="smoking-gun">
                <h3>Smoking Gun, The Complete Absence of a</h3>
                
                <p>
                    We have the vote history data (Election Truth Alliance does too). We can plot the votes for a particular machine over time.                 </p>
                
                <p>
                    This means that there is a very simple graph we can make for our machines. It would actually take *less* effort to produce this next graph than any of the graphs above, and this one has the indisputable power to prove definitively and unambiguously whether the election was manipulated in the way ETA claims or not.                 </p>
                
                <p>
                    Let's take the running average of votes as they come in. If Election Truth Alliance was correct, we would see a huge noticable step in the running average, where before the 250th ballot was inserted, the ballots averaged a certain value, and then after the 250th ballot, they all began trending towards a different value. It would look like this:                 </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702085553.png" alt="Hypothetical step function if vote flipping occurred" class="content-image">
                </div>
                
                <p>
                    This is what it looks like when tabulators suddenly start flipping votes for Trump after 250. If the hackers were sneaky, they might have made it a little less dis-continuous and gradually sloped the cheating up to hide the effect in this style of visualization, but the effect would be the same: at the left edge of the graph we would see all of the lines hovering around some value, and then on the right edge they would be hovering around a different value.                 </p>
                
                <p>
                    However, what we actually find is a normal random walk for each box.
                </p>
            </section>
            
            <!-- Smoking Gun Visualization -->
            <div class="viz-container-light step" id="smoking-gun-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Running Average of Votes</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Line Count:</span>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden; flex-wrap: wrap;">
                            <button type="button" class="smoking-gun-line-count-btn" data-mode="all" 
                                    style="padding: 4px 8px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">All</button>
                            <button type="button" class="smoking-gun-line-count-btn" data-mode="100" 
                                    style="padding: 4px 8px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">100</button>
                            <button type="button" class="smoking-gun-line-count-btn active" data-mode="50" 
                                    style="padding: 4px 8px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">50</button>
                            <button type="button" class="smoking-gun-line-count-btn" data-mode="20" 
                                    style="padding: 4px 8px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">20</button>
                            <button type="button" class="smoking-gun-line-count-btn" data-mode="10" 
                                    style="padding: 4px 8px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">10</button>
                            <button type="button" class="smoking-gun-line-count-btn" data-mode="5" 
                                    style="padding: 4px 8px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.8em; transition: all 0.2s;">5</button>
                        </div>
                        <div style="font-size: 0.8em; color: #666; text-align: center; max-width: 200px;">
                            <em>Note: "All" may take time to load</em>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Selection Method:</span>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden;">
                            <button type="button" class="smoking-gun-selection-btn active" data-mode="longest" 
                                    style="padding: 6px 12px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Longest</button>
                            <button type="button" class="smoking-gun-selection-btn" data-mode="random" 
                                    style="padding: 6px 12px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Random</button>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Simulation:</span>
                        <div class="toggle-container" style="display: flex; align-items: center; gap: 8px;">
                            <label class="toggle-switch" style="position: relative; display: inline-block; width: 50px; height: 24px;">
                                <input type="checkbox" id="smokingGunFakeToggle" style="opacity: 0; width: 0; height: 0;">
                                <span class="toggle-slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;"></span>
                            </label>
                            <span style="font-size: 0.9em;">"What if ETA was right?"</span>
                        </div>
                        <div style="font-size: 0.8em; color: #666; text-align: center; max-width: 250px;">
                            <em>Shows artificial manipulation for educational purposes</em>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Window Size:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="range" id="smokingGunWindowSize" min="5" max="50" value="30" step="1" style="width: 120px;">
                            <span id="smokingGunWindowSizeValue" style="font-size: 0.9em; font-weight: bold; min-width: 25px;">30</span>
                        </div>
                        <div style="font-size: 0.8em; color: #666; text-align: center; max-width: 200px;">
                            <em>Votes included in rolling average</em>
                        </div>
                    </div>
                </div>
                <div id="smoking-gun-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="smoking-gun-plot" class="plot-container"></div>
            </div>

            <section id="smoking-gun-conclusion">
                <p>
                    I can only imagine <sup id="fnref3"><a href="#fn3">[3]</a></sup> why ETA didn't do this visualization, because it is easier than all of the graphs above which required additional vote data accumulation and processing, and it would have proved them right.
                </p>
                
                <p>
                    Election Truth Alliance made one other argument though, that many online have found convincing, we should look at The Russian Tail.                </p>
            </section>
            
            <section id="russian-tail">
                <h2>The "Russian Tail"</h2>
                
                <p>
                    Election Truth Alliance posts the following histogram, graphing the number of machines that report a given Trump percentage. 
                </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702091015.png" alt="ETA histogram showing alleged Russian Tail" class="content-image">
                </div>
                
                <p>
                    ETA states that the pattern above is "Inexplicable", "Statistically unlikely based on typical human voting behavior", and it represents a "Russian Tail", which is a deviation from a normal distribution that can be an indicator of unfair elections.                 
                </p>
                
                <div class="note-box">
                    <!-- Emphasise this more , put it inside a callout box-->
                    <h4>Note</h4>
                    <p>
                        Before moving on, we should discuss why we are drawing a normal distribution here. Pull out that pin from earlier, the Law of Large Numbers states that when you take a bigger sample from a population, your mean sample is closer to the true mean value of the population. There is a similar idea known as the Central Limit Theorem. The Central Limit Theorem states that the distribution of unique samples of uniform size from a certain population, whatever the distribution of the underlying data may be, will approximate a normal distribution.
                    </p>
                    <p>
                        ETA glosses over some of that definition in a deceptive manner. In order for the Central Limit Theorem to hold true, sample populations need to be of <strong>Uniform Size</strong>, but in the Clark County machine data, they span from 10 to 1000 samples. They also need to be pulled from the <strong>same population</strong>. The combined plots of repeated 50/50 coin flip games and 70/30 coin flip games mixed together should <strong>not be expected to be a normal distribution</strong>.
                    </p>
                    <p>
                        Do you expect a sample of votes from your local downtown to have the <em>exact same average result</em> as a sample of votes from a random suburb or outlying village? If the answer is "no" (which it is), then you should not be trying to map geographical voting patterns onto a normal distribution.
                    </p>
                </div>
                
                <h3>What is a Russian Tail?</h3>

                <p>
                    The term "Russian Tail" was coined by data analyst and former political prisoner Roman Udot, to describe a pattern that was noticed in Georgia's Georgian 2020 Constitutional Referendum.                 </p>
                
                <p>
                    Udot noticed that when Georgian precincts were separated out into urban and rural groups, an interesting pattern emerged, where the histogram showing the distribution of precincts and the support proportion they reported deviates from the normal distribution by "growing a tail".                 </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702091704.png" alt="Original Russian Tail example from Georgian referendum" class="content-image">
                </div>
                
                <p>
                    The tail indicates that there are a suspiciously large number of districts that are unanimously or near-unanimously pro-GD, which Udot claims to be evidence of ballot stuffing. The logic is that each of the se precincts would normally be somewhere closer to the center of the normal distribution, but Georgian Dream ballots were stuffed into them after the fact, pushing them rightwards on the graph.                 </p>
                
                <p>
                    Here is a simulation of a Russian Tail that you can play with yourself:
                </p>
            </section>
            
            <!-- Russian Tail Simulation Visualization -->
            <div class="viz-container-light step" id="russian-tail-sim-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Russian Tail Simulation</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Manipulation Level:</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="range" id="russianTailManipulationLevel" min="0" max="30" value="10" step="5" style="width: 120px;">
                            <span id="russianTailManipulationValue" style="font-size: 0.9em; font-weight: bold; min-width: 35px;">10%</span>
                        </div>
                        <div style="font-size: 0.8em; color: #666; text-align: center; max-width: 150px;">
                            <em>of districts</em>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Display Mode:</span>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden;">
                            <button type="button" class="russian-tail-display-btn" data-mode="stacked" 
                                    style="padding: 6px 12px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Stacked</button>
                            <button type="button" class="russian-tail-display-btn active" data-mode="overlapping" 
                                    style="padding: 6px 12px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Overlapping</button>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <button id="russianTailGenerate" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                            Generate Distribution
                        </button>
                    </div>
                </div>
                <div id="russian-tail-sim-plot" class="plot-container"></div>
                <div class="warning" style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px; margin: 20px 0; color: #856404;">
                    <strong>Important:</strong> A bimodal distribution (two peaks) is NORMAL in elections with strong regional divides. A "Russian tail" is specifically a flat distribution at extreme values (80-95%), not just any peak at high percentages.
                </div>
            </div>
            
            <section id="clark-county-russian-tail">
                <h3>Does Clark County have a Russian Tail?</h3>
                
                <p>
                    So, how do we apply this lesson from Roman Udot to Clark County? A hint is in how the original graph from Georgia is presented, with two groups forming two distinct lines, because...                </p>
                
                <p class="lead">
                    <!-- TODO emphasize this more -->
                    Election Precincts do not obey normal distributions, they are multimodal.
                </p>

                <p>
                    "Multimodal" means that there are multiple peaks in the histogram, which makes sense, because all of the machines and all of the precincts do not sample from the same population. They sample from the population of people who live nearby that machine, and the people who live by a voting center are more likely to have more similar opinions to each other than they are to the general population.                 </p>
                
                <p>
                    In Georgia, there were two major populations, Urban and Rural.
                </p>
                
                <p>
                    In Nevada, there are three major populations, Urban, Rural, and Suburban. You may have noticed in some of the charts above that the most-used election machines tended to land on one of three numbers, 75% pro-Trump (Rural), 60% pro-Trump (suburban), and 47% pro-Trump (Urban). 
                </p>
                
                <p>
                    Here's where it gets tricky: where do you draw a line between "urban" and "suburban" Las Vegas? Vegas is one of the most sprawling cities in the world, with an exurban second downtown in Henderson ("The Strip" which is not technically part of the city). Rather than take a stand, I have left "urban" and "suburban" as a single color in these visualizations.                
                </p>
            </section>
            
            <!-- Early Voting Histogram Visualization -->
            <div class="viz-container-light step" id="early-voting-histogram-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Early Voting Histogram</h3>
                
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px;">
                    <div class="control-group">
                        <label>Display Mode:</label>
                        <div class="radio-group">
                            <input type="radio" id="earlyVotingDisplayModeStacked" name="earlyVotingDisplayMode" value="stacked" checked>
                            <label for="earlyVotingDisplayModeStacked">Stacked</label>
                            <input type="radio" id="earlyVotingDisplayModeOverlapping" name="earlyVotingDisplayMode" value="overlapping">
                            <label for="earlyVotingDisplayModeOverlapping">Overlapping</label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Color Mode:</label>
                        <div class="radio-group">
                            <input type="radio" id="earlyVotingColorModeNone" name="earlyVotingColorMode" value="none">
                            <label for="earlyVotingColorModeNone">None (Red)</label>
                            <input type="radio" id="earlyVotingColorModeBinary" name="earlyVotingColorMode" value="binary" checked>
                            <label for="earlyVotingColorModeBinary">Urban/Rural</label>
                        </div>
                    </div>
                </div>
                
                <div id="early-voting-histogram-plot" class="plot-container"></div>
            </div>
            
            <section id="histogram-analysis">
                <p>
                    Compare this view to the Georgian Dream histogram above. There is clearly no "Russian Tail". None of the distributions have a weird shoulder off to the right, like Georgian Dream did.                 </p>
                
                <p>
                    And the election day data, for good measure:
                </p>
            </section>
            
            <!-- Election Day Histogram Visualization -->
            <div class="viz-container-light step" id="election-day-histogram-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Day Histogram</h3>
                
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Display Mode:</span>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden;">
                            <button type="button" class="election-day-display-btn active" data-mode="stacked" 
                                    style="padding: 6px 12px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Stacked</button>
                            <button type="button" class="election-day-display-btn" data-mode="overlapping" 
                                    style="padding: 6px 12px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Overlapping</button>
                        </div>
                    </div>
                    
                    <div class="control-group" style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; font-size: 0.9em;">Color Mode:</span>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden;">
                            <button type="button" class="election-day-color-btn" data-mode="none" 
                                    style="padding: 6px 12px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">None (Red)</button>
                            <button type="button" class="election-day-color-btn active" data-mode="binary" 
                                    style="padding: 6px 12px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Urban/Rural</button>
                        </div>
                    </div>
                </div>
                
                <div id="election-day-histogram-plot" class="plot-container"></div>
            </div>
            
            <section id="population-analysis">
                <p>
                    The fact that we have three populations, not two, but I can only mark two in color, is kind of throwing things off, but we can fix that with some simulation. 
                </p>
                
                <p>
                    In 2024, Republicans made an appeal to their base to vote early, and rural precincts in Nevada saw higher Early Voting turnout overall, Registered Republicans were 51.9% of early voters Registered Democrats were only 27.8% of early voters. This means that <em>there were more Republicans out voting than Democrats, so a pro-Trump result overall is expected*. </em>
                </p>

                <p>
                    There are more early voting locations in urban areas than rural areas, but the same number of tabulator machines at each. This means that the urban mode, especially in early voting, will be smaller overall and more spread out than the rural mode. 
                </p>
                
                <p>
                    So here is our simulation:
                </p>
                <p>
                Urban polling sites are more frequent, and get less votes each, because Democrats were less likely to vote early (they mostly voted by mail). We also assign high variance to urban polling locations, because the average opinion at a polling site in a city can vary based on proximity to job centers or universities. 
                </p>
                <p>
                Suburban polling sites tend to be more homogenous because of the culture of the suburbs, and because they exist at a "crossroads" of urban and rural culture, where they recieve a large number of voters visiting from inside the city and outside. Many of these polling sites were at shopping malls, for example. So they tend to attract more voters and a denser mix. 
                </p>
                <p>
                Rural polling sites are few in number and have few machines each. They will be used by people who come from a broad area around, so they have relatively high total vote counts but a relatively tight distribution, since rural voters broke consistently for Trump. 
                </p>
                <p>
                We plug in these values to our simulation, and we find:
                </p>
            </section>
            
            <!-- Election Simulation Visualization -->
            <div class="viz-container-light step" id="election-simulation-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Distribution Simulation</h3>
                <div id="election-simulation-plot" class="plot-container"></div>
                
                <!-- Simulation Results Box -->
                <div class="simulation-results" style="background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px auto; border-left: 4px solid #27ae60; max-width: 300px; text-align: center;">
                    <h4 style="margin: 0 0 10px 0; color: #27ae60; font-size: 1.1em;">Simulation Results</h4>
                    <div style="display: flex; justify-content: space-between; gap: 20px;">
                        <div><strong>Total Votes:</strong> <span id="simTotalVotes">0</span></div>
                        <div><strong>Trump:</strong> <span id="simTrumpPercent">0.0%</span></div>
                        <div><strong>Harris:</strong> <span id="simHarrisPercent">0.0%</span></div>
                    </div>
                </div>
                
                <h3 style="color: var(--text-secondary); text-align: center; margin: 40px 0 20px 0;">Distribution of Trump Vote % by Machine</h3>
                
                <!-- Histogram Controls -->
                <div class="controls" style="margin: 20px auto; max-width: 800px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                    <div style="display: flex; flex-direction: column; gap: 25px; align-items: center;">
                        <!-- Display Mode Buttons -->
                        <div class="control-group" style="text-align: center;">
                            <h4 style="margin: 0 0 10px 0; color: var(--text-primary); font-size: 1em;">Display Mode</h4>
                            <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden;">
                                <button type="button" class="display-mode-btn" data-mode="stacked" 
                                        style="padding: 8px 16px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Stacked</button>
                                <button type="button" class="display-mode-btn" data-mode="overlapping" 
                                        style="padding: 8px 16px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Overlapping</button>
                            </div>
                        </div>
                        
                        <!-- Color Mode Buttons -->
                        <div class="control-group" style="text-align: center;">
                            <h4 style="margin: 0 0 10px 0; color: var(--text-primary); font-size: 1em;">Color Mode</h4>
                            <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden; flex-wrap: wrap;">
                                <button type="button" class="color-mode-btn" data-mode="ternary" 
                                        style="padding: 8px 16px; border: none; background: #0066cc; color: white; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Urban/Suburban/Rural</button>
                                <button type="button" class="color-mode-btn" data-mode="binary" 
                                        style="padding: 8px 16px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">Urban/Rural Combined</button>
                                <button type="button" class="color-mode-btn" data-mode="unary" 
                                        style="padding: 8px 16px; border: none; background: white; color: #333; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">All Combined (Red)</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="election-simulation-histogram" class="plot-container"></div>
                
                <!-- Educational Explanation -->
                <div class="explanation" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 30px auto; max-width: 800px; border-left: 4px solid var(--primary-color);">
                    <h4 style="margin: 0 0 15px 0; color: var(--primary-color);">What you're seeing:</h4>
                    <p style="margin-bottom: 15px;">Each point represents a voting machine. Machines are grouped into voting locations (clusters), with each location having its own true support rate.</p>
                    
                    <p style="margin-bottom: 10px; font-weight: 600;">We're modeling several real-world patterns:</p>
                    <ul style="margin-left: 20px; line-height: 1.6;">
                        <li><strong>Urban-Rural Divide:</strong> Urban locations (more Democratic-leaning) tend to have more machines but fewer votes per machine. Rural locations (more Republican-leaning) have fewer machines but more votes per machine.</li>
                        <li><strong>Local Clustering:</strong> Machines in the same location have similar Trump support rates, creating clusters in the visualization.</li>
                        <li><strong>Sampling Variability:</strong> Machines with fewer votes show more scatter from their location's true rate due to the Law of Large Numbers.</li>
                    </ul>
                    
                    <p style="margin-top: 15px; font-style: italic;">These patterns create a more realistic simulation that better matches actual election data distributions.</p>
                </div>
            </div>
            
            <section id="simulation-analysis">
                <div class="image-container">
                    <img src="images/Pasted image 20250703145415.png" alt="Simulation results showing three distinct modes" class="content-image">
                </div>
                
                <p>
                    Tadaa! It looks exactly like the real data. No after-vote manipulation happening here, just the exact same population effects we would expect to see in the real world, spelled out in a simulated election.                 
                </p>
                <p>
                    Here, I added the control sliders for this simulation to your control panel, you can see how manipulating the real-world parameters that govern the election impacts the resulting chart. 
                </p>
            </section>
            
            <section id="pattern-of-deception">
                <h2>The Pattern of Deception</h2>
                
                <h3>Manipulative data visualizations</h3>
                
                <p>
                    As pointed out above, Election Truth Alliance visually compares data that is numerically very different by hiding the difference on the X axis legend. Sharing one chart that is compressed in this way against another that includes much larger sample is not an honest comparison.                 </p>
                
                <p>
                    ETA also mirrors their data vertically and superimposes it on itself. There isn't any additional value in doing this, it really baffles me because it just makes the data less readable.                 </p>
                

                <p>
                    The only reason I can imagine to do this is to imply a diverging pattern that does not exist. In reality this is one pattern that converges, but by showing the same graph twice, flipped, ETA implies that there are two trends that *diverge*, which is intuitively less realistic, and therefore stokes the reader's suspicions unless they read closely.
                </p>
                <h3>Just straight up lies</h3>

                <p>
                    A Russian Tail is not a "deviation from a normal distribution", it is a particular kind of deviation, and the kind of it is implicit in the name: it's a tail. A spike is not a tail. 
                </p>
                
                <h3>Cherrypicking</h3>
                
                <p>
                    Election Truth Alliance began crafting their case that the election was stolen within *days* of the election, before the first data set they released was even available. This is a classic telltale of dishonest investigation: the determination was made, the people committed to proving it, <em>even though they didn't look at any evidence yet</em>.                 
                </p>
                
                <p>
                    So the Clark County data eventually came out, and they found a way to make it show the trend that they were already committed to finding before they saw the data, and then they stopped. In the following nine months, they only released two other examples of the supposed manipulations. Why not more? The analysis isn't hard. The visualizations in this post took only about two days to make, the bulk of my time on this project was building the website. 
                </p>
                
                <p>
                    So why did ETA not release any more analyses? Why not any of the other counties in Nevada? 
                </p>

                <p>
                    Could it be that some of the notable visuals seen here is a statistical blip? 
                </p>
                
                <p>
                    Could it be that they don't actually care how right they are, they are just searching through all of the counties in America trying to find examples that confirm their their pre-determined conclusion, and burying all the evidence that disproves them? The answer is yes.                 </p>
                
                
                <h3>About those Audits they are calling for...</h3>
                
                <p class="lead">
                    <!-- TODO emphasize this way more -->
                    There have been audits!
                </p>
                
                <p>
                    <a href="https://elections.wi.gov/sites/default/files/documents/2024%20Post-Election%20Voting%20Equipment%20Audit%20Final%20Report.pdf" target="_blank">Wisconsin performed the largest and most thorough post-election audit in its history</a>, hand-counting more ballots than the total that were recorded in Clark County, and found <em>zero</em> incorrectly tabulated ballots.
                </p>
                <p>
                    When the Wisconsin audit occurred, it fell out of the news cycle fast, because the lack of fraud is normal, it's not newsworthy. That quick news cycle is handy for election conspiracy grifters who can lie, "there have been no audits", and be confident that their audience has forgotten about the audits that have occurred. 
                </p>
            </section>

            <section id="conclusion">
                <p>
                Here's what makes this so frustrating to me, why I spent so much effort on this website: Liberals and leftists take pride in crafting rigorously thought out, scientificaly grounded policies. 
                </p>
                <p>
                The classic Colbert joke that "Reality has a liberal bias" works because the opposite is generally true: liberals orient their beliefs based on the scientific truth, rather than deciding what they want to believe and then making up "alternative facts" about it. 
                </p>
                <p>
                But that's not what's happening here. Election Truth Alliance is bad statistics, bad math, bad science, incurious policy, that exists because the conclusion was fixed before the evidence was seen, and that's not what I want to see my side of the political spectrum doing. 
                </p>
                <p>
                I don't know if Election Truth Alliance are mislead or malicious, but it doesn't matter. They are wrong. Their analysis is fundamentally flawed. The responsible thing to do would be to acknowledge these errors, retract their claims, and apologize for misleading the public. Publications like [Newsweek](https://www.newsweek.com/2024-election-rigged-donald-trump-elon-musk-2019482) that have repeated these claims uncritically should retract their articles and issue corrections. 
                </p>
                <p>
                Bad statistics don't become good just because you want to believe them, and skepticism needs to be applied even when someone is telling you what you want to hear. 
                </p>
            </section>
            
            <!-- Footnotes Section -->
            <section id="footnotes">
                <h3>Footnotes</h3>
                
                <ol>
                    <li id="fn3">I can imagine, actually. It's because they didn't do the analysis properly and were more interested in confirming their pre-existing bias than finding the truth. <a href="#fnref3">↩</a></li>
                </ol>
            </section>
            
        </article>
        
        <!-- Right sidebar: Controls and footnotes -->
        <aside class="right-sidebar" id="controls-sidebar">
            <!-- Close button for mobile -->
            <button class="mobile-close" id="mobile-close-btn" aria-label="Close controls">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
                </svg>
            </button>
            <div class="controls-section">
                <h4 class="desktop-only">Controls</h4>
                <h4 class="mobile-only" style="display: none;">Game Controls</h4>
                
                <!-- Prediction slider - hidden initially -->
                <div class="slider-control" id="predictionControl" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <label>
                        Your Prediction
                        <span class="value">50%</span>
                    </label>
                    <input type="range" min="0" max="100" value="50" id="userPrediction">
                    <div style="font-size: 14px; color: var(--text-secondary); margin-top: 8px;">
                        What percentage of heads do you expect?
                    </div>
                </div>
                
                <!-- Coin bias slider, hidden initially -->
                <div class="slider-control" id="coinBiasControl" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <label>
                        Coin Bias
                        <span class="value">40%</span>
                    </label>
                    <input type="range" min="0" max="100" value="40" id="coinBias">
                </div>
                
                <!-- Global Color Mode Controls -->
                <div class="control-group" id="globalColorControls" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <h5 style="margin-bottom: 10px; color: var(--text-primary);">Color Mode</h5>
                    <div class="radio-group" style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; font-size: 0.9em; cursor: pointer;">
                            <input type="radio" name="globalColorMode" value="none" style="margin-right: 8px;">
                            None
                        </label>
                        <label style="display: flex; align-items: center; font-size: 0.9em; cursor: pointer;">
                            <input type="radio" name="globalColorMode" value="binary" checked style="margin-right: 8px;">
                            Urban/Rural
                        </label>
                        <label style="display: flex; align-items: center; font-size: 0.9em; cursor: pointer;">
                            <input type="radio" name="globalColorMode" value="gradient" style="margin-right: 8px;">
                            Urban %
                        </label>
                    </div>
                </div>
                
                <!-- Election Simulation Controls -->
                <div class="control-group" id="simulationControls" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <h5 style="margin-bottom: 15px; color: var(--text-primary);">Simulation Parameters</h5>
                    
                    <!-- Support Base Controls -->
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Urban Support Base
                            <span class="value" id="urbanSupportBaseValue">45%</span>
                        </label>
                        <input type="range" id="urbanSupportBase" min="0" max="100" value="45" step="1" style="width: 100%;">
                    </div>
                    
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Suburban Support Base
                            <span class="value" id="suburbanSupportBaseValue">60%</span>
                        </label>
                        <input type="range" id="suburbanSupportBase" min="0" max="100" value="60" step="1" style="width: 100%;">
                    </div>
                    
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Rural Support Base
                            <span class="value" id="ruralSupportBaseValue">73%</span>
                        </label>
                        <input type="range" id="ruralSupportBase" min="0" max="100" value="73" step="1" style="width: 100%;">
                    </div>
                    
                    <!-- Machine Distribution Controls -->
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Rural Machines
                            <span class="value" id="ruralMachinesValue">250</span>
                        </label>
                        <input type="range" id="ruralMachines" min="0" max="500" value="250" step="10" style="width: 100%;">
                        <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 2px;">
                            Non-rural: <span id="nonRuralCount">714</span>
                        </div>
                    </div>
                    
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Urban % of Non-Rural
                            <span class="value" id="urbanPercentageValue">55%</span>
                        </label>
                        <input type="range" id="urbanPercentage" min="0" max="100" value="55" step="5" style="width: 100%;">
                        <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 2px;">
                            U: <span id="urbanCount">392</span> | S: <span id="suburbanCount">322</span> | R: <span id="ruralCountDisplay">250</span>
                        </div>
                    </div>
                    
                    <!-- Cluster Variance Controls -->
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Urban Cluster Variance
                            <span class="value" id="urbanClusterStrengthValue">11</span>
                        </label>
                        <input type="range" id="urbanClusterStrength" min="1" max="20" value="11" step="1" style="width: 100%;">
                    </div>
                    
                    <div class="slider-control" style="margin-bottom: 12px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Suburban Cluster Variance
                            <span class="value" id="suburbanClusterStrengthValue">3</span>
                        </label>
                        <input type="range" id="suburbanClusterStrength" min="1" max="20" value="3" step="1" style="width: 100%;">
                    </div>
                    
                    <div class="slider-control" style="margin-bottom: 15px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.85em;">
                            Rural Cluster Variance
                            <span class="value" id="ruralClusterStrengthValue">9</span>
                        </label>
                        <input type="range" id="ruralClusterStrength" min="1" max="20" value="9" step="1" style="width: 100%;">
                    </div>
                    
                    
                    <button id="runSimulation" style="width: 100%; padding: 8px; background: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">Run Simulation</button>
                </div>
            </div>
            
            <!-- Footnotes will appear here dynamically -->
            <div id="footnotes-container">
                <div class="footnote" data-section="intro">
                    <strong>Note:</strong> The Election Truth Alliance's analysis 
                    focused on the convergence of vote percentages as more votes 
                    were counted—a phenomenon we'll explore through simple probability.
                </div>
                <div class="footnote" data-section="single-coin-viz">
                    <strong><sup>1</sup></strong>: Don't worry, it's truly random—the best quality random numbers your computer can generate. I do not know what you are seeing right now.
                </div>
                <div class="footnote" data-section="law-of-large-numbers-explanation">
                    <strong><sup>2</sup></strong>: The Law of Large Numbers is related to but not quite the same as the Central Limit Theorem, put a pin in that.
                    It is also related to but not the same as the confusingly named Law of Very Large Numbers, 
                    which states that unlikely events do still happen sometimes, especially when given enough trials.
                </div>
                <div class="footnote" data-section="smoking-gun-conclusion">
                    <strong><sup>3</sup></strong>: I can imagine, actually. It's because they didn't do the analysis properly and were more 
                    interested in confirming their pre-existing bias than finding the truth. 
                </div>
            </div>
        </aside>
    </div>
    
    <!-- Mobile controls toggle button -->
    <button class="mobile-controls-toggle" id="mobile-controls-toggle" aria-label="Open controls">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/>
        </svg>
    </button>
    
    <!-- Mobile overlay -->
    <div class="mobile-overlay" id="mobile-overlay"></div>
    
    <script type="module">
        // TODOS
        // - Hide coin bias slider by default
        // - Add the bias slider after the reveal
        // - Hide all the coin related sliders once you've scrolled past the coin flip section
        // - maybe have different controls sections and switch which one is active depending on
        //  the direction of the user scroll past the switching point
        // - Download the libs I am reliant on and use them either primarily or as a fallback
        // - automatically highlight the active table of contents item
        // - Add histogram (footnote?) with mail-in votes, also one that combines mail ins and early, to show the curve balance out
        // - ocnvert the rest of the radio toggles to buttons 
        
        // Import our visualization modules
        import { animateCoinFlip } from './src/coin_flip.js';
        import { animateCoins, calculateStats, formatStats } from './src/multi_coin_flip.js';
        import { pregenerateCoinGames, createCoinGamesPlot, updateCoinGamesPlot } from './src/coin_games.js';
        import { createHistogram } from './src/histogram.js';
        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";
        // import * as Plot from "./assets/plot@0.6.esm.js";

        
        // Create separate state for each visualization to avoid conflicts
        const vizStates = {
            global: {
                headsProbability: 0.4
            },
            single: {
                isAnimating: false,
            },
            four: {
                isAnimating: false,
            },
            ten: {
                isAnimating: false,
            },
            coinGames: {
                isAnimating: false,
                coinGames: [],
                maxFlips: 10,
            },
            userPrediction: 50
        };

        /*
        is there a way to make the scrollama a little more robust with the sections? like, it's currently set up with the assumption that you'll scroll fro the top to the bottom, but if you move too fast, it might miss that a trigger point has passed, and so the coin flip sliders are visible in the election section, and vice versa. Also it's a problem when refreshing the page, because you may be far down the page but the trigger to draw the color mode toggle is far up the page. 


        */
        
        // Handle single coin flip
        document.querySelector('button[data-viz="single"]').addEventListener('click', async function() {
            if (vizStates.single.isAnimating) return;
            
            vizStates.single.isAnimating = true;
            const coin = document.querySelector('.coin-container[data-viz="single"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="single"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Tails! (Don\'t worry, I always choose tails)</p>';
            
            // Create a modified version of animateCoinFlip that uses our local state
            coin.style.animation = 'none';
            coin.offsetHeight; // Trigger reflow
            
            // Determine result
            const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
            const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
            coin.style.animation = `${animationName} 2000ms ease-out forwards`;
            const extra_text = result === 'heads' ? 'You Win! 🎉' : 'You Lose! 😔';
            
            setTimeout(() => {
                resultDiv.innerHTML = `<p style="color: var(--text-light);">Result: <strong>${result.toUpperCase()}</strong></p><p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
                vizStates.single.isAnimating = false;
            }, 2000);
        });
        
        // Handle four coins flip
        document.querySelector('button[data-viz="four"]').addEventListener('click', async function() {
            if (vizStates.four.isAnimating) return;
            
            vizStates.four.isAnimating = true;
            const coins = document.querySelectorAll('.coins-grid[data-viz="four"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="four"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Flipping all coins...</p>';
            
            // Animate all coins
            const results = [];
            const promises = Array.from(coins).map((coin, index) => {
                return new Promise((resolve) => {
                    // Clear animation
                    coin.style.animation = 'none';
                    coin.offsetHeight;
                    const resultDiv = 
                    
                    // Random delay for staggered effect
                    setTimeout(() => {
                        const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
                        const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
                        const duration = 2000 + Math.random() * 500;
                        
                        coin.style.animation = `${animationName} ${duration}ms ease-out forwards`;
                        
                        setTimeout(() => {
                            results.push(result);
                            resolve(result);
                        }, duration);
                    }, index * 100); // Stagger by 100ms
                });
            });
            
            // Wait for all coins to finish
            await Promise.all(promises);
            
            // Calculate and display stats
            const stats = calculateStats(results);
            const userPredictionNum = parseInt(vizStates.userPrediction ?? 50);
            const extra_text = (Math.abs(stats.headsPercentage - userPredictionNum) <= 5) ? 'You Win! 🎉' : 'You Lose! 😔';
            resultDiv.innerHTML = formatStats(stats) + `<p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
            vizStates.four.isAnimating = false;
        });

        // Handle ten coins flip
        document.querySelector('button[data-viz="ten"]').addEventListener('click', async function() {
            if (vizStates.ten.isAnimating) return;
            
            vizStates.ten.isAnimating = true;
            const coins = document.querySelectorAll('.ten-coins-grid[data-viz="ten"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="ten"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Flipping all coins...</p>';
            
            // Animate all coins
            const results = [];
            const promises = Array.from(coins).map((coin, index) => {
                return new Promise((resolve) => {
                    // Clear animation
                    coin.style.animation = 'none';
                    coin.offsetHeight;
                    const resultDiv = 
                    
                    // Random delay for staggered effect
                    setTimeout(() => {
                        const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
                        const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
                        const duration = 2000 + Math.random() * 500;
                        
                        coin.style.animation = `${animationName} ${duration}ms ease-out forwards`;
                        
                        setTimeout(() => {
                            results.push(result);
                            resolve(result);
                        }, duration);
                    }, index * 100); // Stagger by 100ms
                });
            });
            
            // Wait for all coins to finish
            await Promise.all(promises);
            
            // Calculate and display stats
            const stats = calculateStats(results);
            const userPredictionNum = parseInt(vizStates.userPrediction ?? 50);
            const extra_text = (Math.abs(stats.headsPercentage - userPredictionNum) <= 10) ? 'You Win! 🎉' : 'You Lose! 😔';
            resultDiv.innerHTML = formatStats(stats) + `<p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
            vizStates.ten.isAnimating = false;
        });
        

        // Coin Games logic
        // Initialize the visualization
        function initCoinGamesVisualization() {
            // Pre-generate all games
            vizStates.coinGames.coinGames = pregenerateCoinGames(vizStates.global.headsProbability);
            
            // Create initial plot
            createCoinGamesPlot('coin-games-plot', vizStates.coinGames.coinGames, {
                maxFlips: vizStates.coinGames.maxFlips,
                guessLower: vizStates.userPrediction - 5,
                guessUpper: vizStates.userPrediction + 5,
                title: "Multiple Coin Flip Games"
            });
            
            // Calculate initial win percentage
            calculateAndDisplayWinPercentage();
            
            // Set up event listeners
            document.getElementById('flips-slider').addEventListener('input', handleFlipsChange);
            document.getElementById('coinBias').addEventListener('input', handleProbabilityChange);
            document.getElementById('userPrediction').addEventListener('input', handleGuessChange);
        }

        // Handler for flips slider change
        function handleFlipsChange(e) {
            const flipsSlider = e.target;
            const flipsDisplay = document.getElementById('flips-display');
            const convergenceNotice = document.getElementById('convergence-notice');
            vizStates.coinGames.maxFlips = parseInt(flipsSlider.value);
            flipsDisplay.textContent = vizStates.coinGames.maxFlips;
            
            // Show/hide convergence notice
            if (vizStates.coinGames.maxFlips > 250) {
                convergenceNotice.style.display = 'block';
                // Trigger opacity transition
                setTimeout(() => {
                    convergenceNotice.style.opacity = '1';
                }, 10);
            } else {
                convergenceNotice.style.opacity = '0';
                setTimeout(() => {
                    convergenceNotice.style.display = 'none';
                }, 500); // Wait for transition to complete
            }
            
            updateCoinVisualization();
        }

        // Handler for probability slider change
        function handleProbabilityChange(e) {
            const probabilitySlider = e.target;
            
            // Regenerate games with new probability
            vizStates.coinGames.coinGames = pregenerateCoinGames(vizStates.global.headsProbability);
            
            updateCoinVisualization();
        }
        
        // Handler for guess range sliders
        function handleGuessChange(e) {
            const userPrediction = e.target;
            vizStates.userPrediction = parseInt(userPrediction.value);
            
            // Update display
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
            
            updateCoinVisualization();
        }
        function updateCoinVisualization() {
            updateCoinGamesPlot('coin-games-plot', vizStates.coinGames.coinGames, {
                maxFlips: vizStates.coinGames.maxFlips,
                guessLower: vizStates.userPrediction - 5,
                guessUpper: vizStates.userPrediction + 5,
                title: "Multiple Coin Flip Games"
            });
            
            // Calculate and display win percentage
            calculateAndDisplayWinPercentage();
        }
        
        function calculateAndDisplayWinPercentage() {
            const games = vizStates.coinGames.coinGames;
            const maxFlips = vizStates.coinGames.maxFlips;
            const lowerBound = vizStates.userPrediction - 5;
            const upperBound = vizStates.userPrediction + 5;
            
            // Count games within the prediction window
            let wins = 0;
            const totalGames = games.length;
            
            games.forEach(game => {
                if (maxFlips <= game.flips.length) {
                    const headsCount = game.flips.slice(0, maxFlips).filter(f => f).length;
                    const headsPercentage = (headsCount / maxFlips) * 100;
                    if (headsPercentage >= lowerBound && headsPercentage <= upperBound) {
                        wins++;
                    }
                }
            });
            
            const winPercentage = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
            const winRateElement = document.getElementById('win-rate-value');
            const winPercentageElement = document.getElementById('win-percentage');
            
            if (winRateElement && winPercentageElement) {
                winRateElement.textContent = `${winPercentage}%`;
                
                // Show win percentage after a short delay
                setTimeout(() => {
                    winPercentageElement.style.opacity = '1';
                }, 300);
                
                // Update color based on win rate
                if (winPercentage >= 70) {
                    winPercentageElement.style.color = 'var(--dark-spring-green)';
                } else if (winPercentage >= 40) {
                    winPercentageElement.style.color = 'var(--olivine)';
                } else {
                    winPercentageElement.style.color = 'var(--auburn)';
                }
            }
        }

        // Initialize when the page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCoinGamesVisualization);
        } else {
            // DOM is already loaded
            initCoinGamesVisualization();
        }


        // Connect sliders to both visualizations
        document.getElementById('coinBias').addEventListener('input', function(e) {
            const value = e.target.value / 100;
            vizStates.global.headsProbability = value;
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
        });
        
        
        // Handle prediction slider
        document.getElementById('userPrediction').addEventListener('input', function(e) {
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
            // Store the prediction for later use
            vizStates.userPrediction = e.target.value;
        });
        
        // Initialize Scrollama instances
        const predictionControl = document.getElementById('predictionControl');
        
        // Set up prediction control visibility using Scrollama
        const predictionScroller = scrollama();
        
        predictionScroller
            .setup({
                step: '#four-coins-viz',
                offset: 0.1, // Trigger when section is 90% up the viewport
                once: true // Only trigger once
            })
            .onStepEnter(response => {
                // Show prediction control when entering four-coins section
                predictionControl.style.display = 'block';
                setTimeout(() => {
                    predictionControl.style.opacity = '1';
                }, 50);
            });

        // Set up bias control visibility using Scrollama
        const biasControl = document.getElementById("coinBiasControl")
        const biasScroller = scrollama();

        biasScroller
            .setup({
                step: '#coin-game-explanation',
                offset: 0.5, // Trigger when section is 90% up the viewport
                once: true // Only trigger once
            })
            .onStepEnter(response => {
                // Show prediction control when entering four-coins section
                biasControl.style.display = 'block';
                setTimeout(() => {
                    biasControl.style.opacity = '1';
                }, 50);
            });

        const coinElectionSwitcher = scrollama();
        coinElectionSwitcher
            .setup({
                step: '#eta-introduction-lead-in',
                offset: 0.5, // Trigger when section is 90% up the viewport
            })
            .onStepEnter(response => {
                // Show coin controls when scrolling up into coin section
                if (response.direction === 'up') {
                    biasControl.style.display = 'block';
                    setTimeout(() => {
                        biasControl.style.opacity = '1';
                    }, 50);
                    predictionControl.style.display = 'block';
                    setTimeout(() => {
                        predictionControl.style.opacity = '1';
                    }, 50);
                } else {
                    biasControl.style.display = 'none';
                    predictionControl.style.display = 'none';
                }
            });
        
        // Set up dynamic footnote system using Scrollama
        const setupFootnotes = () => {
            const footnotes = document.querySelectorAll('.footnote[data-section]');
            const sectionsToFootnotes = new Map();
            
            // Map sections to their footnotes (handle multiple footnotes per section)
            footnotes.forEach(footnote => {
                const sectionId = footnote.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    if (!sectionsToFootnotes.has(section)) {
                        sectionsToFootnotes.set(section, []);
                    }
                    sectionsToFootnotes.get(section).push(footnote);
                }
            });
            
            // Create Scrollama instance for footnotes
            const footnoteScroller = scrollama();
            
            // Get all sections that have footnotes
            const sectionsWithFootnotes = Array.from(sectionsToFootnotes.keys());
            
            footnoteScroller
                .setup({
                    step: sectionsWithFootnotes,
                    offset: 0.6, // Trigger when section is 40% down from top
                    debug: false
                })
                .onStepEnter(response => {
                    const sectionFootnotes = sectionsToFootnotes.get(response.element);
                    if (sectionFootnotes) {
                        // Show footnotes for this section
                        sectionFootnotes.forEach(f => f.classList.add('visible'));
                    }
                })
                .onStepExit(response => {
                    const sectionFootnotes = sectionsToFootnotes.get(response.element);
                    if (sectionFootnotes) {
                        // Hide footnotes for this section when it leaves
                        sectionFootnotes.forEach(f => f.classList.remove('visible'));
                    }
                });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                footnoteScroller.resize();
                predictionScroller.resize();
            });
        };
        
        // Initialize footnotes after DOM is ready
        setupFootnotes();
        
        // Mobile controls functionality
        const setupMobileControls = () => {
            const toggleBtn = document.getElementById('mobile-controls-toggle');
            const closeBtn = document.getElementById('mobile-close-btn');
            const sidebar = document.getElementById('controls-sidebar');
            const overlay = document.getElementById('mobile-overlay');
            
            const openSidebar = () => {
                sidebar.classList.add('mobile-active', 'open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent body scroll
            };
            
            const closeSidebar = () => {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
                document.body.style.overflow = ''; // Restore body scroll
                
                // Remove mobile-active class after transition
                setTimeout(() => {
                    sidebar.classList.remove('mobile-active');
                }, 300);
            };
            
            // Toggle button click
            toggleBtn.addEventListener('click', openSidebar);
            
            // Close button click
            closeBtn.addEventListener('click', closeSidebar);
            
            // Overlay click
            overlay.addEventListener('click', closeSidebar);
            
            // Close on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && sidebar.classList.contains('open')) {
                    closeSidebar();
                }
            });
        };
        
        // Early Voting Scatterplot Functionality
        async function initEarlyVotingScatterplot() {
            document.getElementById('early-voting-loading').style.display = 'block';
            
            try {
                const data = await getEarlyVotingData();
                document.getElementById('early-voting-loading').style.display = 'none';
                globalVisualizationData.earlyVotingData = data;
                createEarlyVotingScatterPlot(data);
                
                // Add event listeners for radio buttons
                document.querySelectorAll('input[name="earlyVotingColorMode"]').forEach(radio => {
                    radio.addEventListener('change', function() {
                        createEarlyVotingScatterPlot(data);
                    });
                });
            } catch (error) {
                console.error('Error loading early voting data:', error);
                document.getElementById('early-voting-loading').textContent = 'Error loading data.';
            }
        }
        
        function createEarlyVotingScatterPlot(data) {
            // Get the selected color mode - try global first, then fallback to local
            let colorMode;
            const globalColorModeElement = document.querySelector('input[name="globalColorMode"]:checked');
            const truncateModeElement = document.querySelector('input[name="earlyVotingColorMode"]:checked');

            if (truncateModeElement && truncateModeElement.value !== "none") {
                colorMode = truncateModeElement.value;
            } else if (globalColorModeElement) {
                colorMode = globalColorModeElement.value;
            } else {
                colorMode = 'binary'; // default fallback
            }
            
            // Process data for the plot
            const plotData = data.map(item => ({
                tabulator: item.tabulator,
                total_votes: item.total_votes,
                trump_percentage: item.trump_percentage,
                area_type: item.is_urban === true ? 'Urban' : 'Rural',
                urban_percentage: item.urban_percentage || 0
            }));
            
            // Create color scale configuration based on color mode
            let colorConfig = {};
            let dotConfig = {};
            
            if (colorMode === 'binary') {
                // Binary Urban/Rural coloring
                dotConfig = {
                    fill: d => d.area_type === 'Urban' ? "blue" : "green",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nArea: ${d.area_type}`
                };
            } else if (colorMode === 'gradient') {
                // Urban percentage gradient coloring
                colorConfig = {
                    scheme: "Cividis",
                    legend: true,
                    label: "Urban %",
                    pivot: 50,
                    domain: [0, 100]
                };
                dotConfig = {
                    stroke: "urban_percentage",
                    fill: "urban_percentage",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nUrban %: ${d.urban_percentage.toFixed(1)}%`
                };
            } else if (colorMode === 'cutoff800') {
                // Cut off at 800 votes with dual candidate display
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
                const kDotConfig = {
                    fill: "blue",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nKamala %: ${(100-d.trump_percentage).toFixed(2)}%`
                };
                
                // Add kamala percentage to data
                for (let i = 0; i < plotData.length; i++) {
                    plotData[i].kamala_percentage = 100 - plotData[i].trump_percentage;
                }
                
                const filteredPlotData = plotData.filter(d => d.total_votes < 800);
                
                // Create the scatter plot with dual candidates
                const plot = Plot.plot({
                    width: 800,
                    height: 500,
                    marginBottom: 50,
                    marginLeft: 60,
                    grid: true,
                    x: {
                        label: "Total Votes per Machine",
                        nice: true,
                        domain: [0, Math.max(...filteredPlotData.map(d => d.total_votes)) * 1.05]
                    },
                    y: {
                        label: "Vote %",
                        nice: true,
                        domain: [0, 100],
                        tickFormat: d => `${d.toFixed(0)}`,
                        grid: true
                    },
                    marks: [
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "trump_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...dotConfig
                        }),
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "kamala_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...kDotConfig
                        })
                    ]
                });
                
                // Clear and append the plot to the container
                const container = document.getElementById('early-voting-scatterplot');
                container.innerHTML = '';
                container.appendChild(plot);
                return;
            } else if (colorMode === 'cutoff125') {
                // Cut off at 125 votes with dual candidate display
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
                const kDotConfig = {
                    fill: "blue",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nKamala %: ${(100-d.trump_percentage).toFixed(2)}%`
                };
                
                // Add kamala percentage to data
                for (let i = 0; i < plotData.length; i++) {
                    plotData[i].kamala_percentage = 100 - plotData[i].trump_percentage;
                }
                
                const filteredPlotData = plotData.filter(d => d.total_votes < 125);
                
                // Create the scatter plot with dual candidates
                const plot = Plot.plot({
                    width: 800,
                    height: 500,
                    marginBottom: 50,
                    marginLeft: 60,
                    grid: true,
                    x: {
                        label: "Total Votes per Machine",
                        nice: true,
                        domain: [0, Math.max(...filteredPlotData.map(d => d.total_votes)) * 1.05]
                    },
                    y: {
                        label: "Vote %",
                        nice: true,
                        domain: [0, 100],
                        tickFormat: d => `${d.toFixed(0)}`,
                        grid: true
                    },
                    marks: [
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "trump_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...dotConfig
                        }),
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "kamala_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...kDotConfig
                        })
                    ]
                });
                
                // Clear and append the plot to the container
                const container = document.getElementById('early-voting-scatterplot');
                container.innerHTML = '';
                container.appendChild(plot);
                return;
            } else {
                // No coloring (red dots)
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
            }
            
            // Create the standard scatter plot
            const plot = Plot.plot({
                width: 800,
                height: 500,
                marginBottom: 50,
                marginLeft: 60,
                grid: true,
                color: colorMode === 'gradient' ? colorConfig : null,
                x: {
                    label: "Total Votes per Machine",
                    nice: true,
                    domain: [0, Math.max(...plotData.map(d => d.total_votes)) * 1.05]
                },
                y: {
                    label: "Trump %",
                    nice: true,
                    domain: [0, 100],
                    tickFormat: d => `${d.toFixed(0)}`,
                    grid: true
                },
                marks: [
                    Plot.dot(plotData, {
                        x: "total_votes",
                        y: "trump_percentage",
                        r: 4,
                        opacity: 0.7,
                        ...dotConfig
                    })
                ]
            });
            
            // Clear and append the plot to the container
            const container = document.getElementById('early-voting-scatterplot');
            container.innerHTML = '';
            container.appendChild(plot);
        }

        const earlyVotingPlotInitializer = scrollama();

        earlyVotingPlotInitializer
            .setup({
                step: document.querySelectorAll('#early-voting-scatterplot-viz'),
                offset: 0.1, // Trigger when section is 90% down the viewport
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                if (response.index === 0) {
                    initEarlyVotingScatterplot();
                }
            });

        // Election Day Scatterplot Functionality
        function initElectionDayScatterplot() {
            // Show loading indicator
            document.getElementById('election-day-loading').style.display = 'block';
            
            // Fetch the election day scatter data
            fetch('data/processed_data/election_day_votes_scatter_data.json')
                .then(response => response.json())
                .then(scatterData => {
                    // Hide loading indicator
                    document.getElementById('election-day-loading').style.display = 'none';
                    
                    // Store data in global state
                    globalVisualizationData.electionDayData = scatterData.data;
                    
                    // Create the scatter plot
                    createElectionDayScatterPlot(scatterData.data);
                    
                    // Add event listeners for radio buttons
                    document.querySelectorAll('input[name="electionDayColorMode"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            createElectionDayScatterPlot(scatterData.data);
                        });
                    });
                })
                .catch(error => {
                    console.error('Error loading election day data:', error);
                    document.getElementById('election-day-loading').textContent = 'Error loading data. Please check console for details.';
                });
        }
        
        function createElectionDayScatterPlot(data) {
            // Get the selected color mode - try global first, then fallback to local
            let colorMode;
            const globalColorModeElement = document.querySelector('input[name="globalColorMode"]:checked');
            const localColorModeElement = document.querySelector('input[name="electionDayColorMode"]:checked');
            
            if (globalColorModeElement) {
                colorMode = globalColorModeElement.value;
            } else if (localColorModeElement) {
                colorMode = localColorModeElement.value;
            } else {
                colorMode = 'binary'; // default fallback
            }
            
            // Process data for the plot
            const plotData = data.map(item => ({
                tabulator: item.tabulator,
                total_votes: item.total_votes,
                trump_percentage: item.trump_percentage,
                area_type: item.is_urban === true ? 'Urban' : 'Rural',
                urban_percentage: item.urban_percentage || 0
            }));
            
            // Create color scale configuration based on color mode
            let colorConfig = {};
            let dotConfig = {};
            
            if (colorMode === 'binary') {
                // Binary Urban/Rural coloring
                dotConfig = {
                    fill: d => d.area_type === 'Urban' ? "blue" : "green",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nArea: ${d.area_type}`
                };
            } else if (colorMode === 'gradient') {
                // Urban percentage gradient coloring
                colorConfig = {
                    scheme: "Cividis",
                    legend: true,
                    label: "Urban %",
                    pivot: 50,
                    domain: [0, 100]
                };
                dotConfig = {
                    stroke: "urban_percentage",
                    fill: "urban_percentage",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nUrban %: ${d.urban_percentage.toFixed(1)}%`
                };
            } else {
                // No coloring (red dots)
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
            }
            
            // Create the scatter plot
            const plot = Plot.plot({
                width: 800,
                height: 500,
                marginBottom: 50,
                marginLeft: 60,
                grid: true,
                color: colorMode === 'gradient' ? colorConfig : null,
                x: {
                    label: "Total Votes per Machine",
                    nice: true,
                    domain: [0, Math.max(...plotData.map(d => d.total_votes)) * 1.05]
                },
                y: {
                    label: "Trump %",
                    nice: true,
                    domain: [0, 100],
                    tickFormat: d => `${d.toFixed(0)}`,
                    grid: true
                },
                marks: [
                    Plot.dot(plotData, {
                        x: "total_votes",
                        y: "trump_percentage",
                        r: 4,
                        opacity: 0.7,
                        ...dotConfig
                    })
                ]
            });
            
            // Clear and append the plot to the container
            const container = document.getElementById('election-day-scatterplot');
            container.innerHTML = '';
            container.appendChild(plot);
        }

        const electionDayPlotInitializer = scrollama();

        electionDayPlotInitializer
            .setup({
                step: document.querySelectorAll('#election-day-scatterplot-viz'),
                offset: 0.1, // Trigger when section is 90% down the viewport
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                if (response.index === 0) {
                    initElectionDayScatterplot();
                }
            });

        // Machine History Visualization Functionality
        async function initMachineHistoryVisualization() {
            document.getElementById('machine-history-loading').style.display = 'block';
            
            const globalColorControls = document.getElementById('globalColorControls');
            globalColorControls.style.display = 'block';
            setTimeout(() => {
                globalColorControls.style.opacity = '1';
            }, 100);
            
            try {
                const data = await getEarlyVotingData();
                document.getElementById('machine-history-loading').style.display = 'none';
                globalVisualizationData.machineHistoryData = data;
                updateMachineHistoryPlot(data);
                
                document.querySelectorAll('input[name="globalColorMode"], input[name="machineHistoryLineCount"], input[name="machineHistorySelectionMethod"]').forEach(radio => {
                    radio.addEventListener('change', () => updateMachineHistoryPlot(data));
                });
            } catch (error) {
                console.error('Error loading machine history data:', error);
                document.getElementById('machine-history-loading').textContent = 'Error loading data.';
            }
        }
        
        function updateMachineHistoryPlot(scatterData) {
            // Get the selected options
            const colorMode = document.querySelector('input[name="globalColorMode"]:checked').value;
            const lineCount = document.querySelector('input[name="machineHistoryLineCount"]:checked').value;
            const selectionMethod = document.querySelector('input[name="machineHistorySelectionMethod"]:checked').value;
            
            // Import and use the game history function
            import('./src/game_history.js').then(module => {
                const { createGameHistoryPlot } = module;
                
                // Create the plot
                createGameHistoryPlot('machine-history-plot', scatterData, {
                    colorMode,
                    lineCount,
                    selectionMethod
                });
            }).catch(error => {
                console.error('Error loading game history module:', error);
            });
        }

        const machineHistoryInitializer = scrollama();

        machineHistoryInitializer
            .setup({
                step: document.querySelectorAll('#machine-history-viz'),
                offset: 0.1, // Trigger when section is 90% down the viewport
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                if (response.index === 0) {
                    initMachineHistoryVisualization();
                }
            });

        // Reversed Game History Functionality
        async function initReversedGameHistory() {
            document.getElementById('reversed-game-history-loading').style.display = 'block';
            
            try {
                const data = await getEarlyVotingData();
                document.getElementById('reversed-game-history-loading').style.display = 'none';
                updateReversedGameHistoryPlot(data);
                
                document.querySelectorAll('input[name="globalColorMode"], input[name="reversedHistoryLineCount"], input[name="reversedHistorySelectionMethod"], input[name="reversedHistoryTimeDirection"]').forEach(radio => {
                    radio.addEventListener('change', () => updateReversedGameHistoryPlot(data));
                });
            } catch (error) {
                console.error('Error loading reversed game history data:', error);
                document.getElementById('reversed-game-history-loading').textContent = 'Error loading data.';
            }
        }
        
        function updateReversedGameHistoryPlot(scatterData) {
            const colorMode = document.querySelector('input[name="globalColorMode"]:checked')?.value || 'binary';
            const lineCount = document.querySelector('input[name="reversedHistoryLineCount"]:checked').value;
            const selectionMethod = document.querySelector('input[name="reversedHistorySelectionMethod"]:checked').value;
            const timeDirection = document.querySelector('input[name="reversedHistoryTimeDirection"]:checked').value;
            
            import('./src/reversed_game_history.js').then(module => {
                const { createReversedGameHistoryPlot } = module;
                createReversedGameHistoryPlot('reversed-game-history-plot', scatterData, {
                    colorMode,
                    lineCount,
                    selectionMethod,
                    timeDirection
                });
            }).catch(error => {
                console.error('Error loading reversed game history module:', error);
            });
        }

        const reversedGameHistoryInitializer = scrollama();
        reversedGameHistoryInitializer
            .setup({
                step: document.querySelectorAll('#reversed-game-history-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("reversed game history enter")
                if (response.index === 0) {
                    initReversedGameHistory();
                }
            });
        
        // Smoking Gun Visualization Functionality
        let smokingGunSelectedRandomTabulators = null;
        
        async function initSmokingGunVisualization() {
            document.getElementById('smoking-gun-loading').style.display = 'block';
            
            try {
                const data = await getEarlyVotingData();
                globalVisualizationData.smokingGunData = data;
                document.getElementById('smoking-gun-loading').style.display = 'none';
                updateSmokingGunPlot(data);
                
                // Initialize button groups for smoking gun controls
                ButtonGroup.init('.smoking-gun-line-count-btn', () => {
                    updateSmokingGunPlot(data);
                });
                
                ButtonGroup.init('.smoking-gun-selection-btn', () => {
                    updateSmokingGunPlot(data);
                });
                
                document.getElementById('smokingGunFakeToggle').addEventListener('change', () => updateSmokingGunPlot(data));
                
                // Window size slider
                const windowSizeSlider = document.getElementById('smokingGunWindowSize');
                const windowSizeValue = document.getElementById('smokingGunWindowSizeValue');
                
                windowSizeSlider.addEventListener('input', function() {
                    windowSizeValue.textContent = this.value;
                    updateSmokingGunPlot(data);
                });
                
                // Global color mode changes
                document.querySelectorAll('input[name="globalColorMode"]').forEach(radio => {
                    radio.addEventListener('change', () => updateSmokingGunPlot(data));
                });
                
            } catch (error) {
                console.error('Error loading smoking gun data:', error);
                document.getElementById('smoking-gun-loading').textContent = 'Error loading data.';
            }
        }
        
        function updateSmokingGunPlot(scatterData) {
            const colorMode = document.querySelector('input[name="globalColorMode"]:checked')?.value || 'binary';
            const lineCount = ButtonGroup.getActiveValue('.smoking-gun-line-count-btn') || '50';
            const selectionMethod = ButtonGroup.getActiveValue('.smoking-gun-selection-btn') || 'longest';
            const windowSize = parseInt(document.getElementById('smokingGunWindowSize').value);
            const fakeDataMode = document.getElementById('smokingGunFakeToggle').checked;
            
            import('./src/rolling_average.js').then(module => {
                const { createRollingAveragePlot } = module;
                createRollingAveragePlot('smoking-gun-plot', scatterData, {
                    colorMode,
                    lineCount,
                    selectionMethod,
                    windowSize,
                    selectedRandomTabulators: smokingGunSelectedRandomTabulators,
                    fakeDataMode
                });
            }).catch(error => {
                console.error('Error loading rolling average module:', error);
            });
        }
        
        const smokingGunInitializer = scrollama();
        smokingGunInitializer
            .setup({
                step: document.querySelectorAll('#smoking-gun-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("smoking gun enter")
                if (response.index === 0) {
                    initSmokingGunVisualization();
                }
            });
        
        // Russian Tail Simulation Functionality
        const russianTailSimulation = {
            manipulationLevel: 10,
            displayMode: 'overlapping',
            data: null
        };
        
        function initRussianTailSimulation() {
            // Generate initial data
            russianTailSimulation.data = generateRussianTailData();
            drawRussianTailChart();
            
            // Add event listeners
            const manipulationSlider = document.getElementById('russianTailManipulationLevel');
            const manipulationValue = document.getElementById('russianTailManipulationValue');
            
            manipulationSlider.addEventListener('input', function() {
                russianTailSimulation.manipulationLevel = parseInt(this.value);
                manipulationValue.textContent = this.value + '%';
                russianTailSimulation.data = generateRussianTailData();
                drawRussianTailChart();
            });
            
            // Initialize Russian Tail display mode button group
            ButtonGroup.init('.russian-tail-display-btn', (mode) => {
                russianTailSimulation.displayMode = mode;
                drawRussianTailChart();
            });
            
            document.getElementById('russianTailGenerate').addEventListener('click', function() {
                russianTailSimulation.data = generateRussianTailData();
                drawRussianTailChart();
            });
        }
        
        function generateRussianTailData() {
            const districts = 2000;
            const manipulations = Math.floor(districts * (russianTailSimulation.manipulationLevel / 100));
            const data = [];
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate normal distributions for non-manipulated districts
            const urbanCount = Math.floor((districts - manipulations) * 0.4);
            const ruralCount = (districts - manipulations) - urbanCount;
            
            // Urban districts - normal distribution centered around 35%
            for (let i = 0; i < urbanCount; i++) {
                let votePercentage = normalRandom(35, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: i, 
                    votePercentage: votePercentage, 
                    type: 'Urban'
                });
            }
            
            // Rural districts - normal distribution centered around 65%
            for (let i = 0; i < ruralCount; i++) {
                let votePercentage = normalRandom(65, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: urbanCount + i, 
                    votePercentage: votePercentage, 
                    type: 'Rural'
                });
            }
            
            // Add manipulated districts (gradually decreasing tail all the way to 100%)
            for (let location = 0; location < manipulations; location++) {
                const randomValue = Math.random();
                let votePercentage;
                
                // Distributing values in specified ranges:
                if (randomValue < 0.6) {
                    // 60% of manipulated districts between 80-90%
                    votePercentage = 80 + ((randomValue) / 0.6) * 10;
                } else if (randomValue < 0.85) {
                    // 25% of manipulated districts between 90-95%
                    votePercentage = 90 + ((randomValue - 0.6) / 0.25) * 5;
                } else if (randomValue < 0.95) {
                    // 10% of manipulated districts between 95-99%
                    votePercentage = 95 + ((randomValue - 0.85) / 0.1) * 4;
                } else {
                    // 5% of manipulated districts between 99-100% (including some at exactly 100%)
                    votePercentage = 99 + ((randomValue - 0.95) / 0.05) * 1;
                }
                
                data.push({
                    district: districts - manipulations + location,
                    votePercentage: votePercentage,
                    type: 'Manipulated'
                });
            }
            
            return data;
        }
        
        function drawRussianTailChart() {
            const data = russianTailSimulation.data;
            if (!data || data.length === 0) return;
            
            import('https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm').then(Plot => {
                // For overlapping mode, combine manipulated with rural
                const dataForOverlapping = russianTailSimulation.displayMode === 'overlapping' 
                    ? data.map(d => ({
                        ...d,
                        type: d.type === 'Manipulated' ? 'Rural' : d.type
                      }))
                    : data;
                
                const marks = russianTailSimulation.displayMode === 'stacked' 
                    ? [
                        Plot.rectY(data, Plot.binX({y: "count"}, {
                            x: "votePercentage",
                            fill: "type",
                            mixBlendMode: "normal",
                            thresholds: 50
                        })),
                        Plot.ruleY([0])
                      ]
                    : [
                        Plot.rectY(dataForOverlapping.filter(d => d.type === 'Urban'), Plot.binX({y2: "count"}, {
                            x: "votePercentage",
                            fill: "#FDEA45",
                            fillOpacity: 0.5,
                            thresholds: 50
                        })),
                        Plot.rectY(dataForOverlapping.filter(d => d.type === 'Rural'), Plot.binX({y2: "count"}, {
                            x: "votePercentage",
                            fill: "#002051",
                            fillOpacity: 0.5,
                            thresholds: 50
                        })),
                        Plot.ruleY([0])
                      ];
                
                const chart = Plot.plot({
                    width: 900,
                    height: 500,
                    marginLeft: 50, 
                    marginRight: 100, 
                    marginTop: 20, 
                    marginBottom: 50,
                    x: {
                        label: "Vote Percentage for Candidate →",
                        domain: [0, 100]
                    },
                    y: {
                        label: "↑ Number of Districts"
                    },
                    color: russianTailSimulation.displayMode === 'stacked' ? {
                        legend: true,
                        domain: ["Urban", "Rural", "Manipulated"],
                        range: ["#FDEA45", "#002051", "#e74c3c"]
                    } : undefined,
                    marks: marks
                });
                
                // Add legend and annotation for overlapping mode
                if (russianTailSimulation.displayMode === 'overlapping') {
                    const legendData = [
                        {x: 780, y: 30, label: "Urban", color: "#FDEA45"},
                        {x: 780, y: 50, label: "Rural + Manipulated", color: "#002051"}
                    ];
                    
                    const annotationMarks = russianTailSimulation.manipulationLevel > 0 ? [
                        Plot.rect([{x1: 80, x2: 100, y1: 0, y2: 100}], {
                            x1: "x1",
                            x2: "x2", 
                            y1: "y1",
                            y2: "y2",
                            fill: "#e74c3c",
                            fillOpacity: 0.1
                        }),
                        Plot.text([{x: 90, y: 80, text: "Russian Tail"}], {
                            x: "x",
                            y: "y",
                            text: "text",
                            fill: "#e74c3c",
                            fontSize: 14,
                            fontWeight: "bold",
                            textAnchor: "middle"
                        })
                    ] : [];
                    
                    const legendChart = Plot.plot({
                        width: 900,
                        height: 500,
                        marginLeft: 50, 
                        marginRight: 100, 
                        marginTop: 20, 
                        marginBottom: 50,
                        x: {
                            label: "Vote Percentage for Candidate →",
                            domain: [0, 100]
                        },
                        y: {
                            label: "↑ Number of Districts"
                        },
                        marks: [
                            ...annotationMarks,
                            ...marks,
                            Plot.dot(legendData, {
                                x: "x",
                                y: "y",
                                r: 6,
                                fill: "color"
                            }),
                            Plot.text(legendData, {
                                x: d => d.x + 15,
                                y: "y",
                                text: "label",
                                textAnchor: "start",
                                dy: 3
                            })
                        ]
                    });
                    
                    document.getElementById('russian-tail-sim-plot').replaceChildren(legendChart);
                    return;
                }
                
                document.getElementById('russian-tail-sim-plot').replaceChildren(chart);
            }).catch(error => {
                console.error('Error loading Plot module:', error);
            });
        }
        
        const russianTailInitializer = scrollama();
        russianTailInitializer
            .setup({
                step: document.querySelectorAll('#russian-tail-sim-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("russian tail enter")
                if (response.index === 0) {
                    initRussianTailSimulation();
                }
            });
        
        // Early Voting Histogram Initialization
        async function initEarlyVotingHistogram() {
            try {
                const response = await fetch('data/processed_data/early_votes_scatter_data.json');
                const scatterData = await response.json();
                const data = scatterData.data;
                
                globalVisualizationData.earlyVotingHistogramData = data;
                
                // Initial histogram creation
                updateEarlyVotingHistogram();
                
                // Add event listeners for controls
                document.querySelectorAll('input[name="earlyVotingDisplayMode"], input[name="earlyVotingColorMode"]').forEach(input => {
                    input.addEventListener('change', updateEarlyVotingHistogram);
                });
            } catch (error) {
                console.error('Error loading early voting histogram data:', error);
            }
        }
        
        // Function to update early voting histogram based on current control settings
        function updateEarlyVotingHistogram() {
            if (!globalVisualizationData.earlyVotingHistogramData) return;
            
            const displayMode = document.querySelector('input[name="earlyVotingDisplayMode"]:checked')?.value || 'stacked';
            const colorMode = document.querySelector('input[name="earlyVotingColorMode"]:checked')?.value || 'binary';
            
            const plotContainer = document.getElementById('early-voting-histogram-plot');
            createHistogram(plotContainer, globalVisualizationData.earlyVotingHistogramData, {
                displayMode,
                colorMode,
                title: '2024 Early Voting in Clark County, NV for Trump'
            });
        }
        
        // Election Day Histogram Initialization
        async function initElectionDayHistogram() {
            try {
                const response = await fetch('data/processed_data/election_day_votes_scatter_data.json');
                const scatterData = await response.json();
                const data = scatterData.data;
                
                globalVisualizationData.electionDayHistogramData = data;
                
                // Initial histogram creation
                updateElectionDayHistogram();
                
                // Initialize button groups for controls
                ButtonGroup.init('.election-day-display-btn', () => {
                    updateElectionDayHistogram();
                });
                
                ButtonGroup.init('.election-day-color-btn', () => {
                    updateElectionDayHistogram();
                });
            } catch (error) {
                console.error('Error loading election day histogram data:', error);
            }
        }
        
        // Function to update election day histogram based on current control settings
        function updateElectionDayHistogram() {
            if (!globalVisualizationData.electionDayHistogramData) return;
            
            const displayMode = ButtonGroup.getActiveValue('.election-day-display-btn') || 'stacked';
            const colorMode = ButtonGroup.getActiveValue('.election-day-color-btn') || 'binary';
            
            const plotContainer = document.getElementById('election-day-histogram-plot');
            createHistogram(plotContainer, globalVisualizationData.electionDayHistogramData, {
                displayMode,
                colorMode,
                title: '2024 Election Day Voting in Clark County, NV for Trump'
            });
        }
        
        // Histogram Scrollama Initializers
        const earlyVotingHistogramInitializer = scrollama();
        earlyVotingHistogramInitializer
            .setup({
                step: document.querySelectorAll('#early-voting-histogram-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("early voting histogram enter")
                if (response.index === 0) {
                    initEarlyVotingHistogram();
                }
            });
        
        const electionDayHistogramInitializer = scrollama();
        electionDayHistogramInitializer
            .setup({
                step: document.querySelectorAll('#election-day-histogram-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("election day histogram enter")
                if (response.index === 0) {
                    initElectionDayHistogram();
                }
            });
        
        // Cached Data Loader
        let cachedEarlyVotingData = null;
        
        async function getEarlyVotingData() {
            if (cachedEarlyVotingData) {
                return cachedEarlyVotingData;
            }
            
            const response = await fetch('data/processed_data/early_votes_scatter_data.json');
            const scatterData = await response.json();
            cachedEarlyVotingData = scatterData.data;
            return cachedEarlyVotingData;
        }
        
        // Global Color Control Management
        let globalVisualizationData = {
            earlyVotingData: null,
            electionDayData: null,
            machineHistoryData: null,
            reversedGameHistoryData: null,
            smokingGunData: null,
            earlyVotingHistogramData: null,
            electionDayHistogramData: null
        };
        
        // Function to update all visualizations when global color mode changes
        function updateAllVisualizationsColorMode() {
            // Update early voting scatterplot if data is available
            if (globalVisualizationData.earlyVotingData) {
                createEarlyVotingScatterPlot(globalVisualizationData.earlyVotingData);
            }
            
            // Update election day scatterplot if data is available
            if (globalVisualizationData.electionDayData) {
                createElectionDayScatterPlot(globalVisualizationData.electionDayData);
            }
            
            // Update machine history if data is available
            if (globalVisualizationData.machineHistoryData) {
                updateMachineHistoryPlot(globalVisualizationData.machineHistoryData);
            }
            
            // Update smoking gun if data is available
            if (globalVisualizationData.smokingGunData) {
                updateSmokingGunPlot(globalVisualizationData.smokingGunData);
            }
            
            // Get current global color mode
            const globalColorMode = document.querySelector('input[name="globalColorMode"]:checked')?.value || 'binary';
            
            // Update early voting histogram if data is available
            if (globalVisualizationData.earlyVotingHistogramData) {
                updateEarlyVotingHistogram();
            }
            
            // Update election day histogram if data is available
            if (globalVisualizationData.electionDayHistogramData) {
                updateElectionDayHistogram();
            }
        }
        
        // Add event listeners for global color controls
        document.querySelectorAll('input[name="globalColorMode"]').forEach(radio => {
            radio.addEventListener('change', updateAllVisualizationsColorMode);
        });
        
        // Reusable Button Group Utilities
        const ButtonGroup = {
            // Initialize a button group with click handlers
            init: function(groupSelector, onChangeCallback) {
                const buttons = document.querySelectorAll(groupSelector);
                buttons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        ButtonGroup.setActive(groupSelector, this);
                        if (onChangeCallback) {
                            onChangeCallback(this.getAttribute('data-mode'), this);
                        }
                    });
                });
            },
            
            // Set a button as active within its group
            setActive: function(groupSelector, activeButton) {
                const buttons = document.querySelectorAll(groupSelector);
                buttons.forEach(btn => {
                    btn.style.background = 'white';
                    btn.style.color = '#333';
                    btn.classList.remove('active');
                });
                activeButton.style.background = '#0066cc';
                activeButton.style.color = 'white';
                activeButton.classList.add('active');
            },
            
            // Get the active button's data-mode value from a group
            getActiveValue: function(groupSelector) {
                const activeBtn = document.querySelector(groupSelector + '.active');
                return activeBtn ? activeBtn.getAttribute('data-mode') : null;
            },
            
            // Set active button by data-mode value
            setActiveByValue: function(groupSelector, value) {
                const targetBtn = document.querySelector(groupSelector + '[data-mode="' + value + '"]');
                if (targetBtn) {
                    ButtonGroup.setActive(groupSelector, targetBtn);
                }
            },
            
            // Create button group HTML structure
            createButtonGroup: function(title, buttons, groupClass, defaultValue) {
                let html = `
                    <div class="control-group" style="text-align: center;">
                        <h4 style="margin: 0 0 10px 0; color: var(--text-primary); font-size: 1em;">${title}</h4>
                        <div class="button-group" style="display: inline-flex; border: 1px solid #ccc; border-radius: 6px; overflow: hidden; flex-wrap: wrap;">
                `;
                
                buttons.forEach(btn => {
                    const isDefault = btn.value === defaultValue;
                    const bgColor = isDefault ? '#0066cc' : 'white';
                    const textColor = isDefault ? 'white' : '#333';
                    const activeClass = isDefault ? ' active' : '';
                    
                    html += `
                        <button type="button" class="${groupClass}${activeClass}" data-mode="${btn.value}" 
                                style="padding: 8px 16px; border: none; background: ${bgColor}; color: ${textColor}; cursor: pointer; font-size: 0.9em; transition: all 0.2s;">${btn.label}</button>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            }
        };
        
        // Election Simulation Functionality
        const simulation = {
            urbanSupportBase: 45,
            ruralSupportBase: 73,
            suburbanSupportBase: 60,
            urbanPercentage: 55,  // Percentage of non-rural machines that are urban
            urbanClusterStrength: 11,
            suburbanClusterStrength: 3,
            ruralClusterStrength: 9,
            // Fixed machine counts based on real election data
            ruralMachines: 250,
            nonRuralMachines: 714,
            totalMachines: 964,
            data: null
        };
        
        function initElectionSimulation() {
            // Generate initial data
            simulation.data = generateElectionData();
            drawSimulationChart(simulation.data);
            drawSimulationHistogram(simulation.data);
            updateSimulationResults(simulation.data);
            
            // Add event listeners for all controls
            setupSimulationControls();
        }
        
        function setupSimulationControls() {
            // Support base sliders - regenerate data on change
            document.getElementById('urbanSupportBase').addEventListener('input', (e) => {
                simulation.urbanSupportBase = parseInt(e.target.value);
                document.getElementById('urbanSupportBaseValue').textContent = e.target.value + '%';
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            document.getElementById('ruralSupportBase').addEventListener('input', (e) => {
                simulation.ruralSupportBase = parseInt(e.target.value);
                document.getElementById('ruralSupportBaseValue').textContent = e.target.value + '%';
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            document.getElementById('suburbanSupportBase').addEventListener('input', (e) => {
                simulation.suburbanSupportBase = parseInt(e.target.value);
                document.getElementById('suburbanSupportBaseValue').textContent = e.target.value + '%';
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            // Machine distribution sliders - regenerate data on change
            document.getElementById('ruralMachines').addEventListener('input', (e) => {
                simulation.ruralMachines = parseInt(e.target.value);
                simulation.nonRuralMachines = simulation.totalMachines - simulation.ruralMachines;
                document.getElementById('ruralMachinesValue').textContent = e.target.value;
                document.getElementById('nonRuralCount').textContent = simulation.nonRuralMachines;
                document.getElementById('ruralCountDisplay').textContent = simulation.ruralMachines;
                
                // Recalculate urban/suburban split
                const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
                const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
                document.getElementById('urbanCount').textContent = urbanMachines;
                document.getElementById('suburbanCount').textContent = suburbanMachines;
                
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            document.getElementById('urbanPercentage').addEventListener('input', (e) => {
                simulation.urbanPercentage = parseInt(e.target.value);
                document.getElementById('urbanPercentageValue').textContent = e.target.value + '%';
                
                // Calculate and display machine counts
                const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
                const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
                document.getElementById('urbanCount').textContent = urbanMachines;
                document.getElementById('suburbanCount').textContent = suburbanMachines;
                
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            // Cluster strength sliders - regenerate data on change
            document.getElementById('urbanClusterStrength').addEventListener('input', (e) => {
                simulation.urbanClusterStrength = parseInt(e.target.value);
                document.getElementById('urbanClusterStrengthValue').textContent = e.target.value;
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            document.getElementById('suburbanClusterStrength').addEventListener('input', (e) => {
                simulation.suburbanClusterStrength = parseInt(e.target.value);
                document.getElementById('suburbanClusterStrengthValue').textContent = e.target.value;
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            document.getElementById('ruralClusterStrength').addEventListener('input', (e) => {
                simulation.ruralClusterStrength = parseInt(e.target.value);
                document.getElementById('ruralClusterStrengthValue').textContent = e.target.value;
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
            
            // Initialize histogram button groups
            ButtonGroup.init('.display-mode-btn', () => {
                if (simulation.data) drawSimulationHistogram(simulation.data);
            });
            
            ButtonGroup.init('.color-mode-btn', () => {
                if (simulation.data) drawSimulationHistogram(simulation.data);
            });
            
            // Run simulation button
            document.getElementById('runSimulation').addEventListener('click', () => {
                simulation.data = generateElectionData();
                drawSimulationChart(simulation.data);
                drawSimulationHistogram(simulation.data);
                updateSimulationResults(simulation.data);
            });
        }
        
        // Generate election data
        function generateElectionData() {
            const data = [];
            const urbanSupportBase = simulation.urbanSupportBase / 100;
            const ruralSupportBase = simulation.ruralSupportBase / 100;
            const suburbanSupportBase = simulation.suburbanSupportBase / 100;
            
            // Calculate actual machine counts
            const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
            const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
            const ruralMachines = simulation.ruralMachines;
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate vote count distribution - right-skewed with long tail
            function generateVoteCount(locationType) {
                if (locationType === "Urban") {
                    const mu = 5.5;
                    const sigma = 0.4;
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                } else if (locationType === "Suburban") {
                    const mu = 5.85;
                    const sigma = 0.45;
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                } else {
                    const mu = 6.1;
                    const sigma = 0.35;
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                }
            }
            
            // Group machines by polling locations (3-5 machines per location)
            function generateMachinesForLocationType(numMachines, locationType, supportBase, clusterStrength, startIndex) {
                const machines = [];
                let machineIndex = 0;
                
                while (machineIndex < numMachines) {
                    const machinesAtLocation = Math.min(numMachines - machineIndex, 
                        Math.floor(Math.random() * 3) + 3);
                    
                    const baseVoteCount = generateVoteCount(locationType);
                    const clusterMean = supportBase;
                    const clusterStdDev = clusterStrength / 100;
                    const locationSupportRate = normalRandom(clusterMean, clusterStdDev);
                    
                    for (let j = 0; j < machinesAtLocation; j++) {
                        const voteVariation = 0.9 + Math.random() * 0.2;
                        const voteCount = Math.round(baseVoteCount * voteVariation);
                        
                        let trumpVotes = 0;
                        for (let voter = 0; voter < voteCount; voter++) {
                            if (Math.random() < locationSupportRate) {
                                trumpVotes++;
                            }
                        }
                        
                        const trumpPercentage = voteCount > 0 ? (trumpVotes / voteCount) * 100 : 0;
                        
                        machines.push({
                            location: startIndex + machineIndex + j,
                            totalVotes: voteCount,
                            trumpPercentage: trumpPercentage,
                            trumpVotes: trumpVotes,
                            supportRate: locationSupportRate * 100,
                            locationType: locationType
                        });
                    }
                    
                    machineIndex += machinesAtLocation;
                }
                
                return machines;
            }
            
            // Generate machines for each location type
            const urbanData = generateMachinesForLocationType(urbanMachines, "Urban", urbanSupportBase, simulation.urbanClusterStrength, 0);
            const suburbanData = generateMachinesForLocationType(suburbanMachines, "Suburban", suburbanSupportBase, simulation.suburbanClusterStrength, urbanMachines);
            const ruralData = generateMachinesForLocationType(ruralMachines, "Rural", ruralSupportBase, simulation.ruralClusterStrength, urbanMachines + suburbanMachines);
            
            data.push(...urbanData, ...suburbanData, ...ruralData);
            return data;
        }
        
        // Draw main scatter plot
        function drawSimulationChart(data) {
            if (!data || data.length === 0) return;
            
            const chart = Plot.plot({
                width: 800,
                height: 500,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Total Votes per Machine →",
                    grid: true,
                    domain: [1, 1250]
                },
                y: {
                    label: "↑ Trump %",
                    domain: [0, 100],
                    grid: true
                },
                color: {
                    type: "categorical",
                    domain: ["Urban", "Suburban", "Rural"],
                    range: ["#FDEA45", "#808080", "#002051"],
                    label: "Location Type",
                    legend: true
                },
                marks: [
                    Plot.dot(data, {
                        x: "totalVotes",
                        y: "trumpPercentage",
                        fill: "locationType",
                        stroke: "gray",
                        strokeWidth: 0.5,
                        r: 3.5,
                        opacity: 0.7,
                        title: d => `Location ${d.location}\nVotes: ${d.totalVotes}, Trump: ${d.trumpPercentage.toFixed(1)}%`
                    }),
                    Plot.ruleY([simulation.urbanSupportBase], {
                        stroke: "#FDEA45",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleY([simulation.suburbanSupportBase], {
                        stroke: "#808080",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleY([simulation.ruralSupportBase], {
                        stroke: "#002051",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.text([{x: 1150, y: simulation.urbanSupportBase}], {
                        text: ["Urban: " + simulation.urbanSupportBase + "%"],
                        fill: "#FDEA45",
                        fontSize: 12,
                        dx: 0
                    }),
                    Plot.text([{x: 1150, y: simulation.suburbanSupportBase}], {
                        text: ["Suburban: " + simulation.suburbanSupportBase + "%"],
                        fill: "#808080",
                        fontSize: 12,
                        dx: 0
                    }),
                    Plot.text([{x: 1150, y: simulation.ruralSupportBase}], {
                        text: ["Rural: " + simulation.ruralSupportBase + "%"],
                        fill: "#002051",
                        fontSize: 12,
                        dx: 0
                    })
                ]
            });
            
            document.getElementById('election-simulation-plot').innerHTML = '';
            document.getElementById('election-simulation-plot').appendChild(chart);
        }
        
        // Draw histogram
        function drawSimulationHistogram(data) {
            if (!data || data.length === 0) return;
            
            // Get selected values using ButtonGroup utility
            const displayMode = ButtonGroup.getActiveValue('.display-mode-btn') || 'stacked';
            const colorMode = ButtonGroup.getActiveValue('.color-mode-btn') || 'ternary';
            
            // Transform data to match expected format
            const transformedData = data.map(d => ({
                trumpPercentage: d.trumpPercentage,
                trump_percentage: d.trumpPercentage,
                locationType: d.locationType,
                urban_percentage: d.locationType === 'Urban' ? 100 : (d.locationType === 'Suburban' ? 50 : 0)
            }));
            
            // Prepare reference lines for the simulation's support bases
            const referenceLines = [
                { value: simulation.urbanSupportBase, color: '#FDEA45' },
                { value: simulation.suburbanSupportBase, color: '#808080' },
                { value: simulation.ruralSupportBase, color: '#002051' }
            ];
            
            // Use the histogram module
            import('./src/histogram.js').then(module => {
                const { createHistogram } = module;
                const container = document.getElementById('election-simulation-histogram');
                container.innerHTML = '';
                createHistogram(container, transformedData, {
                    displayMode,
                    colorMode,
                    title: 'Distribution of Trump Vote % by Machine',
                    referenceLines: colorMode === 'ternary' ? referenceLines : null
                });
            }).catch(error => {
                console.error('Error loading histogram module:', error);
            });
        }
        
        // Update simulation results display
        function updateSimulationResults(data) {
            if (!data || data.length === 0) return;
            
            const totalVotes = data.reduce((sum, d) => sum + d.totalVotes, 0);
            const totalTrumpVotes = data.reduce((sum, d) => sum + d.trumpVotes, 0);
            const trumpPercentage = totalVotes > 0 ? (totalTrumpVotes / totalVotes) * 100 : 0;
            const harrisPercentage = 100 - trumpPercentage;
            
            document.getElementById('simTotalVotes').textContent = totalVotes.toLocaleString();
            document.getElementById('simTrumpPercent').textContent = trumpPercentage.toFixed(1) + '%';
            document.getElementById('simHarrisPercent').textContent = harrisPercentage.toFixed(1) + '%';
        }
        
        // Initialize simulation when scrolled to
        const simulationInitializer = scrollama();
        simulationInitializer
            .setup({
                step: document.querySelectorAll('#election-simulation-viz'),
                offset: 0.1,
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                console.log("simulation enter");
                if (response.index === 0) {
                    initElectionSimulation();
                }
            });
        
        // Show simulation controls when entering simulation section
        const simulationControlsScroller = scrollama();
        simulationControlsScroller
            .setup({
                step: '#election-simulation-viz',
                offset: 0.5,
                once: true
            })
            .onStepEnter(response => {
                const simulationControls = document.getElementById('simulationControls');
                simulationControls.style.display = 'block';
                setTimeout(() => {
                    simulationControls.style.opacity = '1';
                }, 50);
            });
        
        // Initialize mobile controls
        setupMobileControls();
    </script>
</body>
</html>
