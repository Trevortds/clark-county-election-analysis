<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Law of Large Numbers: Understanding Election Statistics</title>
    
    <!-- Dependencies -->
    <script src="https://unpkg.com/scrollama@3.2.0/build/scrollama.min.js"></script>
    
    <style>
        :root {
            /* Color palette */
            --olivine: #a1c489ff;
            --cadet-gray: #96a3a6ff;
            --dark-spring-green: #33774eff;
            --gunmetal: #213231ff;
            --auburn: #9e2a2bff;
            
            /* Derived colors */
            --bg-dark: #26302d;
            --bg-light: #fafafa;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --text-light: #e0e0e0;
            --accent: var(--dark-spring-green);
            --highlight: var(--olivine);
        }
        
        /* Coin Flip Animation Styles */
        @keyframes flip-to-heads {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(1800deg); }
        }
        
        @keyframes flip-to-tails {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(1980deg); }
        }
        
        .coin-container {
            width: 100px;
            height: 100px;
            perspective: 1000px;
            margin: 20px auto;
        }
        
        .coin {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            cursor: pointer;
        }
        
        .coin-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            backface-visibility: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .heads {
            background: var(--olivine);
            color: var(--gunmetal);
        }
        
        .tails {
            background: var(--dark-spring-green);
            color: white;
            transform: rotateY(180deg);
        }
        
        /* Multi-coin grid */
        .coins-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 240px;
            margin: 20px auto;
        }
        
        /* Multi-coin grid */
        .ten-coins-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            max-width: 565px;
            margin: 20px auto;
        }
        
        .coins-grid .coin-container {
            width: 80px;
            height: 80px;
        }
        
        .coins-grid .coin-face {
            font-size: 18px;
        }
        
        /* Viz-specific buttons */
        .viz-button {
            background: var(--dark-spring-green);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .viz-button:hover {
            background: var(--gunmetal);
        }
        
        .viz-result {
            margin-top: 20px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(161, 196, 137, 0.2);
            border-radius: 6px;
            min-height: 50px;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Source Sans Pro', sans-serif;
            background: var(--bg-light);
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 18px;
        }
        
        /* Main layout grid */
        .main-container {
            display: grid;
            grid-template-columns: 170px 1fr 280px;
            max-width: 1440px;
            margin: 0 auto;
            gap: 40px;
            padding: 40px 20px;
            min-height: 100vh;
        }
        
        /* Left navigation (table of contents) */
        .toc-sidebar {
            position: sticky;
            top: 40px;
            height: fit-content;
            padding: 0;
        }
        
        .toc-sidebar h3 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            margin: 0 0 20px 0;
            font-weight: 600;
        }
        
        .toc-sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .toc-sidebar li {
            margin: 0;
        }
        
        .toc-sidebar a {
            display: block;
            padding: 8px 16px 8px 20px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 15px;
            border-left: 3px solid transparent;
            margin-left: -20px;
            transition: all 0.2s ease;
        }
        
        .toc-sidebar a:hover {
            color: var(--text-primary);
            background: rgba(0,0,0,0.02);
        }
        
        .toc-sidebar a.active {
            color: var(--accent);
            border-left-color: var(--accent);
            background: rgba(51, 119, 78, 0.05);
            font-weight: 600;
        }
        
        /* Main content area */
        .article-content {
            max-width: 700px;
            margin: 0 auto;
        }
        
        .article-content h1 {
            font-size: 48px;
            line-height: 1.2;
            margin: 0 0 16px 0;
            font-weight: 700;
            color: var(--gunmetal);
        }
        
        .article-content .subtitle {
            font-size: 22px;
            color: var(--text-secondary);
            margin: 0 0 60px 0;
            font-weight: 400;
        }
        
        .article-content p {
            margin: 0 0 28px 0;
            color: var(--text-primary);
        }
        
        .article-content p.lead {
            font-size: 21px;
            line-height: 1.6;
            color: var(--text-primary);
            font-weight: 400;
        }
        
        /* Right sidebar */
        .right-sidebar {
            position: sticky;
            top: 40px;
            align-self: flex-start;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            /* Hide scrollbar but keep functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        .right-sidebar::-webkit-scrollbar {
            display: none;
        }
        
        .controls-section {
            background: white;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .controls-section h4 {
            margin: 0 0 16px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }
        
        /* Footnotes container - flows below controls */
        #footnotes-container {
            /* Remove sticky positioning to prevent overlap */
            margin-top: 24px;
        }
        
        /* Footnotes in right sidebar */
        .footnote {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-secondary);
            background: rgba(161, 196, 137, 0.08);
            border-left: 3px solid var(--olivine);
            border-radius: 4px;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            max-height: 0;
            overflow: hidden;
            margin-bottom: 0;
            padding: 0 16px;
        }
        
        .footnote.visible {
            opacity: 1;
            transform: translateY(0);
            max-height: 500px; /* Increased to accommodate longer footnotes */
            padding: 16px;
            margin-bottom: 16px;
        }
        
        /* Visualization containers */
        .viz-container {
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 48px;
            margin: 32px -20px;
            position: relative;
        }
        
        .viz-container .viz-placeholder {
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--cadet-gray);
            font-style: italic;
            border: 2px dashed rgba(161, 196, 137, 0.3);
            border-radius: 4px;
        }

        .plot-container {
            width: 100%;
            max-width: 100%;
            margin: 20px auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background-color: white;
        }
        
        /* Light container for graph visualizations */
        .viz-container-light {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 32px 0px;
            margin: 32px -20px;
            position: relative;
        }
        
        .viz-container-light h3 {
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Image container styling */
        .image-container {
            width: 100%;
            max-width: 700px;
            margin: 32px auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: white;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .image-grid .image-container {
            max-width: 100%;
        }
        
        .image-container:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }
        
        .image-container img {
            width: 100%;
            height: auto;
            padding: 10px;
            display: block;
        }
        
        /* Image grid for side-by-side display */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 32px -40px;
            max-width: 900px;
            width: calc(100% + 80px);
        }
        
        .image-grid .image-container {
            margin: 0;
        }
        
        /* Responsive adjustment for small screens */
        @media (max-width: 600px) {
            .image-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Coin games specific slider styling */
        .coin-games-controls {
            width: 100%;
            max-width: 100%;
            margin: 20px auto 0;
        }
        
        .coin-games-controls .slider-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0;
        }
        
        .coin-games-controls label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        .coin-games-controls input[type="range"] {
            flex: 1;
            margin: 0 16px;
        }
        
        .coin-games-controls .value {
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }
        
        /* Sliders and controls */
        .slider-control {
            margin-bottom: 24px;
        }
        
        .slider-control label {
            display: block;
            font-size: 14px;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .slider-control input[type="range"] {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--dark-spring-green);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-control .value {
            float: right;
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
        }
        
        /* Mobile Controls Bubble */
        .mobile-controls-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--auburn);
            border-radius: 50%;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .mobile-controls-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }
        
        .mobile-controls-toggle svg {
            width: 30px;
            height: 30px;
            fill: white;
        }
        
        /* Mobile overlay for sidebar */
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .mobile-overlay.active {
            opacity: 1;
        }
        
        /* Close button for mobile */
        .mobile-close {
            display: none;
        }
        
        /* Responsive adjustments */
        @media (max-width: 968px) {
            /* Adjust main grid for tablet/mobile */
            .main-container {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px 15px;
            }
            
            /* Hide sidebars on mobile */
            .toc-sidebar,
            .right-sidebar {
                display: none;
            }
            
            /* Show mobile controls toggle */
            .mobile-controls-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Transform right sidebar into mobile panel */
            .right-sidebar.mobile-active {
                display: block;
                position: fixed;
                right: 0;
                top: 0;
                height: 100vh;
                width: 300px;
                max-width: 85vw;
                background: white;
                z-index: 1001;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                box-shadow: -4px 0 16px rgba(0,0,0,0.1);
                padding: 60px 20px 20px;
                overflow-y: auto;
            }
            
            .right-sidebar.mobile-active.open {
                transform: translateX(0);
            }
            
            /* Show close button on mobile */
            .mobile-close {
                display: block;
                position: absolute;
                top: 15px;
                right: 15px;
                width: 32px;
                height: 32px;
                background: none;
                border: none;
                cursor: pointer;
                padding: 0;
                z-index: 1002;
            }
            
            .mobile-close svg {
                width: 24px;
                height: 24px;
                fill: var(--text-secondary);
            }
            
            /* Full width containers on mobile */
            .viz-container,
            .viz-container-light {
                margin: 20px -15px;
                border-radius: 0;
                padding: 32px 15px;
            }
            
            /* Adjust article content */
            .article-content {
                padding: 0;
            }
            
            .article-content h1 {
                font-size: 36px;
            }
            
            .article-content h2 {
                font-size: 28px;
            }
            
            /* Show overlay on mobile */
            .mobile-overlay {
                display: block;
            }
            
            /* Mobile-specific text */
            .desktop-only {
                display: none;
            }
            
            .mobile-only {
                display: block !important;
            }
        }
        
        /* Desktop-specific text */
        @media screen and (min-width: 969px) {
            .mobile-only {
                display: none !important;
            }
            
            .desktop-only {
                display: block;
            }
        }
    </style>
    
    <!-- Scrollama library -->
    <script src="https://unpkg.com/scrollama"></script>
</head>
<body>
    <div class="main-container">
        <!-- Left sidebar: Table of Contents -->
        <nav class="toc-sidebar">
            <h3>Contents</h3>
            <ul>
                <li><a href="#intro" class="active">Introduction</a></li>
                <li><a href="#coin-flip">The Coin Flip Game</a></li>
                <li><a href="#law-of-large">Law of Large Numbers</a></li>
                <li><a href="#election-data">Election Data Analysis</a></li>
                <li><a href="#smoking-gun">The "Smoking Gun"</a></li>
                <li><a href="#conclusion">Conclusion</a></li>
            </ul>
        </nav>
        
        <!-- Main content area -->
        <article class="article-content">
            <h1>The Fraud Behind 2024 Election Fraud Claims</h1>
            <p class="subtitle">How the Election Truth Alliance misunderstood Stats 101, decieved themselves, and created a new conspiracy subculture</p>
            
            <section id="coin-flip">
                <h2> Let's play a game </h2>
                <p> You flip a coin, I'll call it. </p>
            </section>  
          
            <!-- First Visualization: Single Coin -->
            <div class="viz-container" id="single-coin-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Single Coin Flip</h3>
                <div class="coin-container" data-viz="single">
                    <div class="coin">
                        <div class="coin-face heads">H</div>
                        <div class="coin-face tails">T</div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="single">Flip the Coin!</button>
                    <div class="viz-result" data-viz="single"></div>
                </div>
            </div>
            
            <section id="four-coins">
                <p>
                    Now let's make things more interesting. Instead of flipping one coin, let's flip four coins 
                    at once. Can you predict what percentage will be heads?
                </p>
                
                <p>
                    With more coins, we start to see patterns emerge. The results become more predictable, 
                    even though each individual coin flip is still random. This is the beginning of understanding 
                    the Law of Large Numbers.
                </p>
            </section>
            
            <!-- Second Visualization: Four Coins -->
            <div class="viz-container step" id="four-coins-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Four Coins</h3>
                <div class="coins-grid" data-viz="four">
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="four">Flip All Four!</button>
                    <div class="viz-result" data-viz="four"></div>
                </div>
            </div>

            <section id="ten-coins">
                <p>
                    Let's do ten coins now. How many will be heads. Put in your guess:
                </p>
            </section>

            <!-- Third Visualization: Ten Coins -->
            <div class="viz-container step" id="ten-coins-viz">
                <h3 style="color: var(--text-light); text-align: center; margin-bottom: 30px;">Ten Coins</h3>
                <div class="ten-coins-grid" data-viz="ten">
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                    <div class="coin-container">
                        <div class="coin">
                            <div class="coin-face heads">H</div>
                            <div class="coin-face tails">T</div>
                        </div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="viz-button" data-viz="ten">Flip All Ten!</button>
                    <div class="viz-result" data-viz="ten"></div>
                </div>
            </div>
            <section id="coin-games">
                <p>
                    I get the feeling you feel like you can win more often than you have, so 
                    I'll make it easy for you. 
                </p>
                <p>
                    I'll run 20 games at once, and put them on a chart for you, 
                    and this time you get to pick how many coins are tossed. You only need to be correct within a 10% window.
                </p>
            </section>

            <!-- Fourth Visualization: Coin Games -->
            <div class="viz-container-light step" id="coin-games-viz">
                <div id="coin-games-plot" class="plot-container"></div>
                <div class="coin-games-controls">
                    <div class="slider-control">
                        <label>Number of Flips:</label>
                        <input type="range" id="flips-slider" min="10" max="1000" value="0" step="10">
                        <span class="value" id="flips-display">10</span>
                    </div>
                    <p style="text-align: center; font-size: 14px; color: var(--text-secondary); margin-top: 8px;">Slide to change how many flips are done for each game</p>
                    <p id="win-percentage" style="text-align: center; font-size: 18px; color: var(--dark-spring-green); font-weight: 600; margin-top: 12px; opacity: 0; transition: opacity 0.3s ease-in;">Your win rate: <span id="win-rate-value">0%</span></p>
                    <p id="convergence-notice" style="text-align: center; font-size: 28px; color: var(--auburn); font-weight: bold; margin-top: 20px; display: none; opacity: 0; transition: opacity 0.5s ease-in;">Hey, wait a minute...</p>
                </div>
            </div>
            
            
            <section id="coin-game-explanation">
                <p class="lead">
                    I forgot to mention, the coins that we've been flipping prefer to land on tails. Here, you can make them fair if you want, or bias them towards you.
                </p>
                
            </section>   
            <section id="law-of-large-numbers-explanation">
                <p class="lead">
                    I did not lie to you about the outcomes of any of our prediction games, I just withheld the underlying preferences of the coins. You were able to detect those preferences by playing a large number of games with a large number of flips each. The more flips in a game, the closer the average result was to the true value of the coin. 
                </p>
                <h3>
                    What you've just experienced is the Law of Large Numbers <sup>2</sup> and it is a centerpiece of statistics. Arguably, it is why we even do statistics <strong><em>at all</em></strong>.
                </h3>
                <p>
                    The fact that variance around the mean is guaranteed to decrease as more samples are taken is critical for decision making using statistics. This is why scientists look for the largest test groups they can get their hands on for running experiments. [ maybe remove the casino thing, casinos are associated with unfairness and that's not the point. ] This is also why casinos are never afraid for their profits: even though the outcome of any individual game can be very hard to predict, and the house may frequently lose several games in a row, over the long run, the average outcome of thousands of games will converge to the "house edge", their initial likelihood of winning. 
                </p>
                <p>
                    The Law of Large Numbers tells us that the more samples we take from some hard-to-predict source, the closer the average will be to the true value we are sampling from. More samples, more consistent and accurate results. 
                </p>
            </section>
            
            
            <section id="eta-introduction-lead-in">
                <p class="lead">
                    Now we are ready to talk about Election Truth Alliance
                </p>
            </section>
            
            <section id="eta-introduction">
                <h2>Introduction</h2>
                
                <p>
                    Election Truth Alliance is self-declared Election Watchdog incorporated on January 13 2025, three-person team composed of Lilli McGregor (Canadian civil servant), Nathan Taylor ("cybersecurity specialist", works as a 25B tech support for the US Army, job description includes "connecting printers" and "resetting passwords"), and "Jive", the anonymous executive director who "envisioned and articulated the need for our organization", the only detail we know is that they are an "auditor and accountant". 
                </p>

                <p>
                    This group coalesced very shortly after the 2024 US Federal election, as early as November 13, and began preparing to publish arguments that the election was rigged at that point in time, even before much of the data that they would later be basing their work on was released. 
                </p>
                
                <p>
                    In March 2025, Election Truth Alliance debuted their proof that the 2024 US Presidential election was stolen by means of electronic vote flipping. This post will be focused on their original analysis of Clark County Nevada. 
                </p>
                
                <p>
                    Election Truth Alliance claims that Nevada vote records show that voting machines were altered to start flipping Presidential votes in favor of Trump after 250 or so votes were cast. 
                </p>
                
                <p>
                    I have reproduced their charts to confirm their methodology, and I will explain how that methodology does not show what they claim it does. I will show you what Election Truth Alliance found in the Clark County Cast Vote Records, why it looks suspicious to them, and why it is exactly what we'd expect to see.
                </p>
                
                <h3>Who am I?</h3>
                
                <p>
                    I am a person who cares deeply about election integrity, which is why misleading statistical claims concern me regardless of their source and in support of which candidate. 
                </p>
            </section>
            
            <section id="main-chart">
                <h2>The Main Chart</h2>
                
                <p>
                    Election Truth Alliance's analysis focus on this chart, which they claim is anomalous. To understand how to read this chart, keep in mind that each point is not a vote, but an entire voting machine. The numbers on the X axis are the number of votes each machine has counted, and the Y axis is Trump preference.                 </p>

                <div class="image-container">
                    <img src="images/Pasted image 20250702074913.png" alt="ETA main analysis chart showing voting machines" class="content-image">
                </div>

                <p>
                    Here's what Election Truth Alliance has to say about this chart: 
                </p>

                <p>
                    <!-- TODO pop this out into a quote block -->
                    > Expected randomness in the Early Voting results are observed **until approximately 250 ballots have been processed. Beyond that range, a visible shift is observed** once the number of ballots processed exceeds the threshold, resulting in a **high degree of clustering and unusual uniformity**, a departure from expected human voting behavior. The pattern is more distinct (closer to 60% votes for Trump, closer to 40% votes for Harris) with more ballots processed by a given voting machine.

                    > Rather than an expected distribution of votes, similar to Election Day votes, the Early Voting data suggests there may be a correlation between the quantity of ballots processed and the overall candidate vote percentage. 
                </p>

                <p>
                So, are they right? Is this data anomalous? 
                </p>
                <p>
                Clearly the machines tend to converge at around 60% Pro-Trump as the number of votes counted by each machine increases, as they say. But **is that proof of tampering**? 
                </p>
                <p>
                    To answer that for yourself, think back to the coin game we played above. If I said, "rather than showing an expected distribution of coin flips, the coin flipping games showed a correlation between the number of coin flips and the overall heads percentage", does that describe a manipulation affecting the results, or does that describe what the game naturally does when you increase the number of flips per game?
                </p>
                <p>
                    Let's go back to Election Truth Alliance for a second, because they say that these graphs are "abnormal" compared to Election Day votes. So what do Election Day votes look like? 
                </p>
                <p>
                    I have to preface this by pointing out that for some reason ETA often vertically mirrors their graphs back on themselves, switching the color to blue. They are showing the exact same data in both colors, just for the red dots, the top of the graph is Trump preference and the bottom is Harris preference, and in the blue graph it's vice-versa. It's the same data. 
                </p>
                <p>
                    So, our point of comparison is this:
                </p>
            
                <div class="image-container">
                    <img src="images/Pasted image 20250702080329.png" alt="ETA mirrored chart showing the same data in different colors" class="content-image">
                </div>

                <p>
                    And here is what Election Truth Alliance claims is a "normal" Election Day chart:
                </p>
                <div class="image-grid">
                    <div class="image-container">
                        <img src="images/Pasted image 20250702080345.png" alt="ETA normal early-voting election chart" class="content-image">
                    </div>
                    
                    <div class="image-container">
                        <img src="images/Pasted image 20250702075428.png" alt="ETA General election chart" class="content-image">
                    </div>
                </div>
                
                <p>
                    If you don't immediately see the problem here, I don't blame you, it's one of the oldest tricks in the bad-statistics book.                 </p>
            </section>
            
            <section id="x-axis-analysis">
                <h3>The X Axis</h3>
                
                <p>
                    Take a look at the X axis in these graphs. The "normal" elections max out at 800 or 100 votes per machine, but the 2024 Early Voting election has as many as 1200 votes per machine! We can't tell what the election day machines would have done if they had 1200 votes, because none of them cracked 125!                 </p>
                
                <p>
                    If we truncate the Early Voting chart so that we have an apples-to-apples comparison along the same width of X axis as the 2020 early votes...
                </p>
                <div class="image-grid">
                    <div class="image-container">
                        <img src="images/Pasted image 20250702080345.png" alt="ETA normal early-voting election chart" class="content-image">
                    </div>
                    
                    <div class="image-container">
                        <img src="images/Pasted image 20250702081653.png" alt="Truncated early voting chart for fair comparison" class="content-image">
                    </div>
                </div>

                <p>
                    They look identical! Note how both of the graphs do very clearly show a tendency to start converging in the same way.                 
                </p>
                
                <p>
                    Either the 2020 election was manipulated in the exact same way as ETA is claiming that 2024 was manipulated, or comparing these charts to each other does not prove manipulation. 
                </p>

                <p>
                    If you want to peruse the data further, here are some interactive visualizations of the 2024 Cast Vote Records, both for Early Voting and Election Day voting                
                </p>
            </section>
            
            <!-- Early Voting Scatterplot Visualization -->
            <div class="viz-container-light step" id="early-voting-scatterplot-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Early Voting Scatterplot</h3>
                <div class="controls" style="margin: 20px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; max-width: 900px; margin-left: auto; margin-right: auto;">
                    <div class="radio-container" style="display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px;">
                        <span style="font-weight: bold; margin-right: 8px; white-space: nowrap;">Color Mode:</span>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="none" style="margin-right: 4px;">
                            None
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="binary" checked style="margin-right: 4px;">
                            Urban/Rural
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="gradient" style="margin-right: 4px;">
                            Urban %
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="cutoff800" style="margin-right: 4px;">
                            < 800 votes
                        </label>
                        <label style="margin-right: 8px; white-space: nowrap; font-size: 0.9em;">
                            <input type="radio" name="earlyVotingColorMode" value="cutoff125" style="margin-right: 4px;">
                            < 125 votes
                        </label>
                    </div>
                </div>
                <div id="early-voting-loading" style="text-align: center; margin: 20px 0;">Loading data...</div>
                <div id="early-voting-scatterplot" class="plot-container"></div>
            </div>
            
            <!-- Election Day Scatterplot Visualization -->
            <div class="viz-container-light step" id="election-day-scatterplot-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Day Scatterplot</h3>
                <div id="election-day-scatterplot" class="plot-container"></div>
            </div>
            
            <section id="machine-history">
                <h3>The Machine History</h3>
                
                <p>
                    Remember, the dots in the graphs above are <em>machines</em> not <em>votes</em>. Each dot is a machine tabulator. The analysis provided by Election Truth Alliance is not based on a time-wise analysis of the votes as they went in, but rather a guess based on the tallies that came out of machines with more or less total votes. 
                </p>

                <p>
                    However, we <em>do</em> have access to the vote data, on each machine, in the order the votes were cast. 
                </p>
                
                <p>
                    This means that we can play a history game, just like we did with the coin flips above, showing each machine's average vote as each new vote is added to it. We can watch the election play out on each machine over time, and see the running tallies as the ballots go in!                 </p>
                
                <p>
                    I have also given you the option to color the machines by their location, urban or rural. Nevada allows voters to vote at any location, so each machine at each voting site will get a mix of voters from many places, but if most of the people who used a machine live in rural precincts, we can surmise that the machine was in a rural location. Similarly if most of the votes on a machine came from voters who live in urban precincts, that machine was probably in an urban area. Machines with an even split were likely placed on the urban periphery, (perhaps near suburban shopping centers that attract people from inside and outside the city).                </p>
            </section>
            
            <!-- Machine History Visualization -->
            <div class="viz-container-light step" id="machine-history-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Machine Vote History</h3>
                <div id="machine-history-plot" class="plot-container"></div>
            </div>
            <section id="machine-history-analysis">
                <p>
                    As you can see, every machine quickly finds its way to a stable average, and that average correlates not with the number of votes total on the machine (they don't progress upwards as the graph continues right), they level out. We know from the coin flip game above that the point they level out at is the true opinion of the group they are sampling from, which is why the vertical axis does correlate so strongly to color. Rural people were more likely to support Trump, urban people more likely to support Kamala, and suburban people, whose voting sites got a mix of both in large numbers, leaned towards Trump.                 </p>
                
                <p>
                    Okay, so what? The machines all converge to various numbers. What does this mean for our analysis?                 
                </p>
                <p>
                    Well, Election Truth Alliance's allegation is that the machines started flipping votes to maintain a certain level of Trump support starting at 200 or so votes.
                </p>
                <p>
                    So let's see if that's true. Let's run time backwards. 
                </p>
                
                <p>
                    The next visualization will show the voting history of each machine *as if* the ballots were inserted in the opposite order, from last to first.                 </p>
                
                <p>
                    If Election Truth Alliance is correct, we would see something like this, where starting from the last vote cast and working backwards in time to the first vote, each machine will show a solid line of "manipulated" votes, and then when they hit the magical 250-votes-left threshold when they suddenly bloom out to a variety of "true" vote counts.                 </p>
                
                <div class="image-container">
                    <img src="images/Reversed_voting_game_history.png" alt="Hypothetical reversed voting history if ETA was correct" class="content-image">
                </div>
                
                <p>
                    Instead what we see is this:
                </p>
            </section>
            
            <!-- Reversed Game History Visualization -->
            <div class="viz-container-light step" id="reversed-game-history-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Reversed Voting History</h3>
                <div id="reversed-game-history-plot" class="plot-container"></div>
            </div>
            
            <section id="reversed-game-analysis">
                <p>
                    It looks the same!
                </p>

                <p class="lead">
                    <!-- TODO emphasize this more -->
                    Because this isn't what fraud looks like, this is what counting looks like.
                </p>
            </section>
            
            <section id="smoking-gun">
                <h3>Smoking Gun, The Complete Absence of a</h3>
                
                <p>
                    We have the vote history data (Election Truth Alliance does too). We can plot the votes for a particular machine over time.                 </p>
                
                <p>
                    This means that there is a very simple graph we can make for our machines. It would actually take *less* effort to produce this next graph than any of the graphs above, and this one has the indisputable power to prove definitively and unambiguously whether the election was manipulated in the way ETA claims or not.                 </p>
                
                <p>
                    Let's take the running average of votes as they come in. If Election Truth Alliance was correct, we would see a huge noticable step in the running average, where before the 250th ballot was inserted, the ballots averaged a certain value, and then after the 250th ballot, they all began trending towards a different value. It would look like this:                 </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702085553.png" alt="Hypothetical step function if vote flipping occurred" class="content-image">
                </div>
                
                <p>
                    This is what it looks like when tabulators suddenly start flipping votes for Trump after 250. If the hackers were sneaky, they might have made it a little less dis-continuous and gradually sloped the cheating up to hide the effect in this style of visualization, but the effect would be the same: at the left edge of the graph we would see all of the lines hovering around some value, and then on the right edge they would be hovering around a different value.                 </p>
                
                <p>
                    However, what we actually find is a normal random walk for each box.
                </p>
            </section>
            
            <!-- Smoking Gun Visualization -->
            <div class="viz-container-light step" id="smoking-gun-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Running Average of Votes</h3>
                <div id="smoking-gun-plot" class="plot-container"></div>
            </div>

            <section id="smoking-gun-conclusion">
                <p>
                    I can only imagine <sup id="fnref3"><a href="#fn3">[3]</a></sup> why ETA didn't do this visualization, because it is easier than all of the graphs above which required additional vote data accumulation and processing, and it would have proved them right.
                </p>
                
                <p>
                    Election Truth Alliance made one other argument though, that many online have found convincing, we should look at The Russian Tail.                </p>
            </section>
            
            <section id="russian-tail">
                <h2>The "Russian Tail"</h2>
                
                <p>
                    Election Truth Alliance posts the following histogram, graphing the number of machines that report a given Trump percentage. 
                </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702091015.png" alt="ETA histogram showing alleged Russian Tail" class="content-image">
                </div>
                
                <p>
                    ETA states that the pattern above is "Inexplicable", "Statistically unlikely based on typical human voting behavior", and it represents a "Russian Tail", which is a deviation from a normal distribution that can be an indicator of unfair elections.                 
                </p>
                
                <div class="note-box">
                    <h4>Note</h4>
                    <p>
                        Before moving on, we should discuss why we are drawing a normal distribution here. Pull out that pin from earlier, the Law of Large Numbers states that when you take a bigger sample from a population, your mean sample is closer to the true mean value of the population. There is a similar idea known as the Central Limit Theorem. The Central Limit Theorem states that the distribution of unique samples of uniform size from a certain population, whatever the distribution of the underlying data may be, will approximate a normal distribution.
                    </p>
                    <p>
                        ETA glosses over some of that definition in a deceptive manner. In order for the Central Limit Theorem to hold true, sample populations need to be of <strong>Uniform Size</strong>, but in the Clark County machine data, they span from 10 to 1000 samples. They also need to be pulled from the <strong>same population</strong>. The combined plots of repeated 50/50 coin flip games and 70/30 coin flip games mixed together should <strong>not be expected to be a normal distribution</strong>.
                    </p>
                    <p>
                        Do you expect a sample of votes from your local downtown to have the <em>exact same average result</em> as a sample of votes from a random suburb or outlying village? If the answer is "no" (which it is), then you should not be trying to map geographical voting patterns onto a normal distribution.
                    </p>
                </div>
                
                <h3>What is a Russian Tail?</h3>

                <p>
                    The term "Russian Tail" was coined by data analyst and former political prisoner Roman Udot, to describe a pattern that was noticed in Georgia's Georgian 2020 Constitutional Referendum.                 </p>
                
                <p>
                    Udot noticed that when Georgian precincts were separated out into urban and rural groups, an interesting pattern emerged, where the histogram showing the distribution of precincts and the support proportion they reported deviates from the normal distribution by "growing a tail".                 </p>
                
                <div class="image-container">
                    <img src="images/Pasted image 20250702091704.png" alt="Original Russian Tail example from Georgian referendum" class="content-image">
                </div>
                
                <p>
                    The tail indicates that there are a suspiciously large number of districts that are unanimously or near-unanimously pro-GD, which Udot claims to be evidence of ballot stuffing. The logic is that each of the se precincts would normally be somewhere closer to the center of the normal distribution, but Georgian Dream ballots were stuffed into them after the fact, pushing them rightwards on the graph.                 </p>
                
                <p>
                    Here is a simulation of a Russian Tail that you can play with yourself:
                </p>
            </section>
            
            <!-- Russian Tail Simulation Visualization -->
            <div class="viz-container-light step" id="russian-tail-sim-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Russian Tail Simulation</h3>
                <div id="russian-tail-sim-plot" class="plot-container"></div>
            </div>
            
            <section id="clark-county-russian-tail">
                <h3>Does Clark County have a Russian Tail?</h3>
                
                <p>
                    So, how do we apply this lesson from Roman Udot to Clark County? A hint is in how the original graph from Georgia is presented, with two groups forming two distinct lines, because...                </p>
                
                <p class="lead">
                    <!-- TODO emphasize this more -->
                    Election Precincts do not obey normal distributions, they are multimodal.
                </p>

                <p>
                    "Multimodal" means that there are multiple peaks in the histogram, which makes sense, because all of the machines and all of the precincts do not sample from the same population. They sample from the population of people who live nearby that machine, and the people who live by a voting center are more likely to have more similar opinions to each other than they are to the general population.                 </p>
                
                <p>
                    In Georgia, there were two major populations, Urban and Rural.
                </p>
                
                <p>
                    In Nevada, there are three major populations, Urban, Rural, and Suburban. You may have noticed in some of the charts above that the most-used election machines tended to land on one of three numbers, 75% pro-Trump (Rural), 60% pro-Trump (suburban), and 47% pro-Trump (Urban). 
                </p>
                
                <p>
                    Here's where it gets tricky: where do you draw a line between "urban" and "suburban" Las Vegas? Vegas is one of the most sprawling cities in the world, with an exurban second downtown in Henderson ("The Strip" which is not technically part of the city). Rather than take a stand, I have left "urban" and "suburban" as a single color in these visualizations.                
                </p>
            </section>
            
            <!-- Early Voting Histogram Visualization -->
            <div class="viz-container-light step" id="early-voting-histogram-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Early Voting Histogram</h3>
                <div id="early-voting-histogram-plot" class="plot-container"></div>
            </div>
            
            <section id="histogram-analysis">
                <p>
                    Compare this view to the Georgian Dream histogram above. There is clearly no "Russian Tail". None of the distributions have a weird shoulder off to the right, like Georgian Dream did.                 </p>
                
                <p>
                    And the election day data, for good measure:
                </p>
            </section>
            
            <!-- Election Day Histogram Visualization -->
            <div class="viz-container-light step" id="election-day-histogram-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Day Histogram</h3>
                <div id="election-day-histogram-plot" class="plot-container"></div>
            </div>
            
            <section id="population-analysis">
                <p>
                    The fact that we have three populations, not two, but I can only mark two in color, is kind of throwing things off, but we can fix that with some simulation. 
                </p>
                
                <p>
                    In 2024, Republicans made an appeal to their base to vote early, and rural precincts in Nevada saw higher Early Voting turnout overall, Registered Republicans were 51.9% of early voters Registered Democrats were only 27.8% of early voters. This means that <em>there were more Republicans out voting than Democrats, so a pro-Trump result overall is expected*. </em>
                </p>

                <p>
                    There are more early voting locations in urban areas than rural areas, but the same number of tabulator machines at each. This means that the urban mode, especially in early voting, will be smaller overall and more spread out than the rural mode. 
                </p>
                
                <p>
                    So here is our simulation:
                </p>
                <p>
                Urban polling sites are more frequent, and get less votes each, because Democrats were less likely to vote early (they mostly voted by mail). We also assign high variance to urban polling locations, because the average opinion at a polling site in a city can vary based on proximity to job centers or universities. 
                </p>
                <p>
                Suburban polling sites tend to be more homogenous because of the culture of the suburbs, and because they exist at a "crossroads" of urban and rural culture, where they recieve a large number of voters visiting from inside the city and outside. Many of these polling sites were at shopping malls, for example. So they tend to attract more voters and a denser mix. 
                </p>
                <p>
                Rural polling sites are few in number and have few machines each. They will be used by people who come from a broad area around, so they have relatively high total vote counts but a relatively tight distribution, since rural voters broke consistently for Trump. 
                </p>
                <p>
                We plug in these values to our simulation, and we find:
                </p>
            </section>
            
            <!-- Election Simulation Visualization -->
            <div class="viz-container-light step" id="election-simulation-viz">
                <h3 style="color: var(--text-secondary); text-align: center; margin-bottom: 20px;">Election Distribution Simulation</h3>
                <div id="election-simulation-plot" class="plot-container"></div>
            </div>
            
            <section id="simulation-analysis">
                <div class="image-container">
                    <img src="images/Pasted image 20250703145415.png" alt="Simulation results showing three distinct modes" class="content-image">
                </div>
                
                <p>
                    Tadaa! It looks exactly like the real data. No after-vote manipulation happening here, just the exact same population effects we would expect to see in the real world, spelled out in a simulated election.                 
                </p>
                <p>
                    Here, I added the control sliders for this simulation to your control panel, you can see how manipulating the real-world parameters that govern the election impacts the resulting chart. 
                </p>
            </section>
            
            <section id="pattern-of-deception">
                <h2>The Pattern of Deception</h2>
                
                <h3>Manipulative data visualizations</h3>
                
                <p>
                    As pointed out above, Election Truth Alliance visually compares data that is numerically very different by hiding the difference on the X axis legend. Sharing one chart that is compressed in this way against another that includes much larger sample is not an honest comparison.                 </p>
                
                <p>
                    ETA also mirrors their data vertically and superimposes it on itself. There isn't any additional value in doing this, it really baffles me because it just makes the data less readable.                 </p>
                

                <p>
                    The only reason I can imagine to do this is to imply a diverging pattern that does not exist. In reality this is one pattern that converges, but by showing the same graph twice, flipped, ETA implies that there are two trends that *diverge*, which is intuitively less realistic, and therefore stokes the reader's suspicions unless they read closely.
                </p>
                <h3>Just straight up lies</h3>

                <p>
                    A Russian Tail is not a "deviation from a normal distribution", it is a particular kind of deviation, and the kind of it is implicit in the name: it's a tail. A spike is not a tail. 
                </p>
                
                <h3>Cherrypicking</h3>
                
                <p>
                    Election Truth Alliance began crafting their case that the election was stolen within *days* of the election, before the first data set they released was even available. This is a classic telltale of dishonest investigation: the determination was made, the people committed to proving it, <em>even though they didn't look at any evidence yet</em>.                 
                </p>
                
                <p>
                    So the Clark County data eventually came out, and they found a way to make it show the trend that they were already committed to finding before they saw the data, and then they stopped. In the following nine months, they only released two other examples of the supposed manipulations. Why not more? The analysis isn't hard. The visualizations in this post took only about two days to make, the bulk of my time on this project was building the website. 
                </p>
                
                <p>
                    So why did ETA not release any more analyses? Why not any of the other counties in Nevada? 
                </p>

                <p>
                    Could it be that some of the notable visuals seen here is a statistical blip? 
                </p>
                
                <p>
                    Could it be that they don't actually care how right they are, they are just searching through all of the counties in America trying to find examples that confirm their their pre-determined conclusion, and burying all the evidence that disproves them? The answer is yes.                 </p>
                
                
                <h3>About those Audits they are calling for...</h3>
                
                <p class="lead">
                    <!-- TODO emphasize this way more -->
                    There have been audits!
                </p>
                
                <p>
                    <a href="https://elections.wi.gov/sites/default/files/documents/2024%20Post-Election%20Voting%20Equipment%20Audit%20Final%20Report.pdf" target="_blank">Wisconsin performed the largest and most thorough post-election audit in its history</a>, hand-counting more ballots than the total that were recorded in Clark County, and found <em>zero</em> incorrectly tabulated ballots.
                </p>
                <p>
                    When the Wisconsin audit occurred, it fell out of the news cycle fast, because the lack of fraud is normal, it's not newsworthy. That quick news cycle is handy for election conspiracy grifters who can lie, "there have been no audits", and be confident that their audience has forgotten about the audits that have occurred. 
                </p>
            </section>

            <section id="conclusion">
                <p>
                Here's what makes this so frustrating to me, why I spent so much effort on this website: Liberals and leftists take pride in crafting rigorously thought out, scientificaly grounded policies. 
                </p>
                <p>
                The classic Colbert joke that "Reality has a liberal bias" works because the opposite is generally true: liberals orient their beliefs based on the scientific truth, rather than deciding what they want to believe and then making up "alternative facts" about it. 
                </p>
                <p>
                But that's not what's happening here. Election Truth Alliance is bad statistics, bad math, bad science, incurious policy, that exists because the conclusion was fixed before the evidence was seen, and that's not what I want to see my side of the political spectrum doing. 
                </p>
                <p>
                I don't know if Election Truth Alliance are mislead or malicious, but it doesn't matter. They are wrong. Their analysis is fundamentally flawed. The responsible thing to do would be to acknowledge these errors, retract their claims, and apologize for misleading the public. Publications like [Newsweek](https://www.newsweek.com/2024-election-rigged-donald-trump-elon-musk-2019482) that have repeated these claims uncritically should retract their articles and issue corrections. 
                </p>
                <p>
                Bad statistics don't become good just because you want to believe them, and skepticism needs to be applied even when someone is telling you what you want to hear. 
                </p>
            </section>
            
            <!-- Footnotes Section -->
            <section id="footnotes">
                <h3>Footnotes</h3>
                
                <ol>
                    <li id="fn3">I can imagine, actually. It's because they didn't do the analysis properly and were more interested in confirming their pre-existing bias than finding the truth. <a href="#fnref3">↩</a></li>
                </ol>
            </section>
            
        </article>
        
        <!-- Right sidebar: Controls and footnotes -->
        <aside class="right-sidebar" id="controls-sidebar">
            <!-- Close button for mobile -->
            <button class="mobile-close" id="mobile-close-btn" aria-label="Close controls">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
                </svg>
            </button>
            <div class="controls-section">
                <h4 class="desktop-only">Controls</h4>
                <h4 class="mobile-only" style="display: none;">Game Controls</h4>
                
                <!-- Prediction slider - hidden initially -->
                <div class="slider-control" id="predictionControl" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <label>
                        Your Prediction
                        <span class="value">50%</span>
                    </label>
                    <input type="range" min="0" max="100" value="50" id="userPrediction">
                    <div style="font-size: 14px; color: var(--text-secondary); margin-top: 8px;">
                        What percentage of heads do you expect?
                    </div>
                </div>
                
                <!-- Coin bias slider, hidden initially -->
                <div class="slider-control" id="coinBiasControl" style="display: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
                    <label>
                        Coin Bias
                        <span class="value">40%</span>
                    </label>
                    <input type="range" min="0" max="100" value="40" id="coinBias">
                </div>
            </div>
            
            <!-- Footnotes will appear here dynamically -->
            <div id="footnotes-container">
                <div class="footnote" data-section="intro">
                    <strong>Note:</strong> The Election Truth Alliance's analysis 
                    focused on the convergence of vote percentages as more votes 
                    were counted—a phenomenon we'll explore through simple probability.
                </div>
                <div class="footnote" data-section="single-coin-viz">
                    <strong><sup>1</sup></strong>: Don't worry, it's truly random—the best quality random numbers your computer can generate. I do not know what you are seeing right now.
                </div>
                <div class="footnote" data-section="law-of-large-numbers-explanation">
                    <strong><sup>2</sup></strong>: The Law of Large Numbers is related to but not quite the same as the Central Limit Theorem, put a pin in that.
                    It is also related to but not the same as the confusingly named Law of Very Large Numbers, 
                    which states that unlikely events do still happen sometimes, especially when given enough trials.
                </div>
                <div class="footnote" data-section="smoking-gun-conclusion">
                    <strong><sup>3</sup></strong>: I can imagine, actually. It's because they didn't do the analysis properly and were more 
                    interested in confirming their pre-existing bias than finding the truth. 
                </div>
            </div>
        </aside>
    </div>
    
    <!-- Mobile controls toggle button -->
    <button class="mobile-controls-toggle" id="mobile-controls-toggle" aria-label="Open controls">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/>
        </svg>
    </button>
    
    <!-- Mobile overlay -->
    <div class="mobile-overlay" id="mobile-overlay"></div>
    
    <script type="module">
        // TODOS
        // - Hide coin bias slider by default
        // - Add the bias slider after the reveal
        // - Hide all the coin related sliders once you've scrolled past the coin flip section
        // - maybe have different controls sections and switch which one is active depending on
        //  the direction of the user scroll past the switching point
        // - Download the libs I am reliant on and use them either primarily or as a fallback
        // - automatically highlight the active table of contents item
        
        // Import our visualization modules
        import { animateCoinFlip } from './src/coin_flip.js';
        import { animateCoins, calculateStats, formatStats } from './src/multi_coin_flip.js';
        import { pregenerateCoinGames, createCoinGamesPlot, updateCoinGamesPlot } from './src/coin_games.js';
        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";
        // import * as Plot from "./assets/plot@0.6.esm.js";

        
        // Create separate state for each visualization to avoid conflicts
        const vizStates = {
            global: {
                headsProbability: 0.4
            },
            single: {
                isAnimating: false,
            },
            four: {
                isAnimating: false,
            },
            ten: {
                isAnimating: false,
            },
            coinGames: {
                isAnimating: false,
                coinGames: [],
                maxFlips: 10,
            },
            userPrediction: 50
        };
        
        // Handle single coin flip
        document.querySelector('button[data-viz="single"]').addEventListener('click', async function() {
            if (vizStates.single.isAnimating) return;
            
            vizStates.single.isAnimating = true;
            const coin = document.querySelector('.coin-container[data-viz="single"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="single"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Tails! (Don\'t worry, I always choose tails)</p>';
            
            // Create a modified version of animateCoinFlip that uses our local state
            coin.style.animation = 'none';
            coin.offsetHeight; // Trigger reflow
            
            // Determine result
            const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
            const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
            coin.style.animation = `${animationName} 2000ms ease-out forwards`;
            const extra_text = result === 'heads' ? 'You Win! 🎉' : 'You Lose! 😔';
            
            setTimeout(() => {
                resultDiv.innerHTML = `<p style="color: var(--text-light);">Result: <strong>${result.toUpperCase()}</strong></p><p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
                vizStates.single.isAnimating = false;
            }, 2000);
        });
        
        // Handle four coins flip
        document.querySelector('button[data-viz="four"]').addEventListener('click', async function() {
            if (vizStates.four.isAnimating) return;
            
            vizStates.four.isAnimating = true;
            const coins = document.querySelectorAll('.coins-grid[data-viz="four"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="four"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Flipping all coins...</p>';
            
            // Animate all coins
            const results = [];
            const promises = Array.from(coins).map((coin, index) => {
                return new Promise((resolve) => {
                    // Clear animation
                    coin.style.animation = 'none';
                    coin.offsetHeight;
                    const resultDiv = 
                    
                    // Random delay for staggered effect
                    setTimeout(() => {
                        const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
                        const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
                        const duration = 2000 + Math.random() * 500;
                        
                        coin.style.animation = `${animationName} ${duration}ms ease-out forwards`;
                        
                        setTimeout(() => {
                            results.push(result);
                            resolve(result);
                        }, duration);
                    }, index * 100); // Stagger by 100ms
                });
            });
            
            // Wait for all coins to finish
            await Promise.all(promises);
            
            // Calculate and display stats
            const stats = calculateStats(results);
            const userPredictionNum = parseInt(vizStates.userPrediction ?? 50);
            const extra_text = (Math.abs(stats.headsPercentage - userPredictionNum) <= 5) ? 'You Win! 🎉' : 'You Lose! 😔';
            resultDiv.innerHTML = formatStats(stats) + `<p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
            vizStates.four.isAnimating = false;
        });

        // Handle ten coins flip
        document.querySelector('button[data-viz="ten"]').addEventListener('click', async function() {
            if (vizStates.ten.isAnimating) return;
            
            vizStates.ten.isAnimating = true;
            const coins = document.querySelectorAll('.ten-coins-grid[data-viz="ten"] .coin');
            const resultDiv = document.querySelector('.viz-result[data-viz="ten"]');
            
            // Clear previous result
            resultDiv.innerHTML = '<p style="color: var(--text-secondary);">Flipping all coins...</p>';
            
            // Animate all coins
            const results = [];
            const promises = Array.from(coins).map((coin, index) => {
                return new Promise((resolve) => {
                    // Clear animation
                    coin.style.animation = 'none';
                    coin.offsetHeight;
                    const resultDiv = 
                    
                    // Random delay for staggered effect
                    setTimeout(() => {
                        const result = Math.random() < vizStates.global.headsProbability ? 'heads' : 'tails';
                        const animationName = result === 'heads' ? 'flip-to-heads' : 'flip-to-tails';
                        const duration = 2000 + Math.random() * 500;
                        
                        coin.style.animation = `${animationName} ${duration}ms ease-out forwards`;
                        
                        setTimeout(() => {
                            results.push(result);
                            resolve(result);
                        }, duration);
                    }, index * 100); // Stagger by 100ms
                });
            });
            
            // Wait for all coins to finish
            await Promise.all(promises);
            
            // Calculate and display stats
            const stats = calculateStats(results);
            const userPredictionNum = parseInt(vizStates.userPrediction ?? 50);
            const extra_text = (Math.abs(stats.headsPercentage - userPredictionNum) <= 10) ? 'You Win! 🎉' : 'You Lose! 😔';
            resultDiv.innerHTML = formatStats(stats) + `<p style="color: var(--olivine); font-weight: 600; font-size: 18px; margin-top: 10px;">${extra_text}</p>`;
            vizStates.ten.isAnimating = false;
        });
        

        // Coin Games logic
        // Initialize the visualization
        function initCoinGamesVisualization() {
            // Pre-generate all games
            vizStates.coinGames.coinGames = pregenerateCoinGames(vizStates.global.headsProbability);
            
            // Create initial plot
            createCoinGamesPlot('coin-games-plot', vizStates.coinGames.coinGames, {
                maxFlips: vizStates.coinGames.maxFlips,
                guessLower: vizStates.userPrediction - 5,
                guessUpper: vizStates.userPrediction + 5,
                title: "Multiple Coin Flip Games"
            });
            
            // Calculate initial win percentage
            calculateAndDisplayWinPercentage();
            
            // Set up event listeners
            document.getElementById('flips-slider').addEventListener('input', handleFlipsChange);
            document.getElementById('coinBias').addEventListener('input', handleProbabilityChange);
            document.getElementById('userPrediction').addEventListener('input', handleGuessChange);
        }

        // Handler for flips slider change
        function handleFlipsChange(e) {
            const flipsSlider = e.target;
            const flipsDisplay = document.getElementById('flips-display');
            const convergenceNotice = document.getElementById('convergence-notice');
            vizStates.coinGames.maxFlips = parseInt(flipsSlider.value);
            flipsDisplay.textContent = vizStates.coinGames.maxFlips;
            
            // Show/hide convergence notice
            if (vizStates.coinGames.maxFlips > 250) {
                convergenceNotice.style.display = 'block';
                // Trigger opacity transition
                setTimeout(() => {
                    convergenceNotice.style.opacity = '1';
                }, 10);
            } else {
                convergenceNotice.style.opacity = '0';
                setTimeout(() => {
                    convergenceNotice.style.display = 'none';
                }, 500); // Wait for transition to complete
            }
            
            updateCoinVisualization();
        }

        // Handler for probability slider change
        function handleProbabilityChange(e) {
            const probabilitySlider = e.target;
            
            // Regenerate games with new probability
            vizStates.coinGames.coinGames = pregenerateCoinGames(vizStates.global.headsProbability);
            
            updateCoinVisualization();
        }
        
        // Handler for guess range sliders
        function handleGuessChange(e) {
            const userPrediction = e.target;
            vizStates.userPrediction = parseInt(userPrediction.value);
            
            // Update display
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
            
            updateCoinVisualization();
        }
        function updateCoinVisualization() {
            updateCoinGamesPlot('coin-games-plot', vizStates.coinGames.coinGames, {
                maxFlips: vizStates.coinGames.maxFlips,
                guessLower: vizStates.userPrediction - 5,
                guessUpper: vizStates.userPrediction + 5,
                title: "Multiple Coin Flip Games"
            });
            
            // Calculate and display win percentage
            calculateAndDisplayWinPercentage();
        }
        
        function calculateAndDisplayWinPercentage() {
            const games = vizStates.coinGames.coinGames;
            const maxFlips = vizStates.coinGames.maxFlips;
            const lowerBound = vizStates.userPrediction - 5;
            const upperBound = vizStates.userPrediction + 5;
            
            // Count games within the prediction window
            let wins = 0;
            const totalGames = games.length;
            
            games.forEach(game => {
                if (maxFlips <= game.flips.length) {
                    const headsCount = game.flips.slice(0, maxFlips).filter(f => f).length;
                    const headsPercentage = (headsCount / maxFlips) * 100;
                    if (headsPercentage >= lowerBound && headsPercentage <= upperBound) {
                        wins++;
                    }
                }
            });
            
            const winPercentage = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
            const winRateElement = document.getElementById('win-rate-value');
            const winPercentageElement = document.getElementById('win-percentage');
            
            if (winRateElement && winPercentageElement) {
                winRateElement.textContent = `${winPercentage}%`;
                
                // Show win percentage after a short delay
                setTimeout(() => {
                    winPercentageElement.style.opacity = '1';
                }, 300);
                
                // Update color based on win rate
                if (winPercentage >= 70) {
                    winPercentageElement.style.color = 'var(--dark-spring-green)';
                } else if (winPercentage >= 40) {
                    winPercentageElement.style.color = 'var(--olivine)';
                } else {
                    winPercentageElement.style.color = 'var(--auburn)';
                }
            }
        }

        // Initialize when the page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCoinGamesVisualization);
        } else {
            // DOM is already loaded
            initCoinGamesVisualization();
        }


        // Connect sliders to both visualizations
        document.getElementById('coinBias').addEventListener('input', function(e) {
            const value = e.target.value / 100;
            vizStates.global.headsProbability = value;
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
        });
        
        
        // Handle prediction slider
        document.getElementById('userPrediction').addEventListener('input', function(e) {
            e.target.previousElementSibling.querySelector('.value').textContent = e.target.value + '%';
            // Store the prediction for later use
            vizStates.userPrediction = e.target.value;
        });
        
        // Initialize Scrollama instances
        const predictionControl = document.getElementById('predictionControl');
        
        // Set up prediction control visibility using Scrollama
        const predictionScroller = scrollama();
        
        predictionScroller
            .setup({
                step: '#four-coins-viz',
                offset: 0.1, // Trigger when section is 90% up the viewport
                once: true // Only trigger once
            })
            .onStepEnter(response => {
                // Show prediction control when entering four-coins section
                predictionControl.style.display = 'block';
                setTimeout(() => {
                    predictionControl.style.opacity = '1';
                }, 50);
            });

        // Set up bias control visibility using Scrollama
        const biasControl = document.getElementById("coinBiasControl")
        const biasScroller = scrollama();

        biasScroller
            .setup({
                step: '#coin-game-explanation',
                offset: 0.5, // Trigger when section is 90% up the viewport
                once: true // Only trigger once
            })
            .onStepEnter(response => {
                // Show prediction control when entering four-coins section
                biasControl.style.display = 'block';
                setTimeout(() => {
                    biasControl.style.opacity = '1';
                }, 50);
            });

        const coinElectionSwitcher = scrollama();
        coinElectionSwitcher
            .setup({
                step: '#eta-introduction-lead-in',
                offset: 0.5, // Trigger when section is 90% up the viewport
            })
            .onStepEnter(response => {
                // Show coin controls when scrolling up into coin section
                if (response.direction === 'up') {
                    biasControl.style.display = 'block';
                    setTimeout(() => {
                        biasControl.style.opacity = '1';
                    }, 50);
                    predictionControl.style.display = 'block';
                    setTimeout(() => {
                        predictionControl.style.opacity = '1';
                    }, 50);
                } else {
                    biasControl.style.display = 'none';
                    predictionControl.style.display = 'none';
                }
            });
        
        // Set up dynamic footnote system using Scrollama
        const setupFootnotes = () => {
            const footnotes = document.querySelectorAll('.footnote[data-section]');
            const sectionsToFootnotes = new Map();
            
            // Map sections to their footnotes (handle multiple footnotes per section)
            footnotes.forEach(footnote => {
                const sectionId = footnote.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    if (!sectionsToFootnotes.has(section)) {
                        sectionsToFootnotes.set(section, []);
                    }
                    sectionsToFootnotes.get(section).push(footnote);
                }
            });
            
            // Create Scrollama instance for footnotes
            const footnoteScroller = scrollama();
            
            // Get all sections that have footnotes
            const sectionsWithFootnotes = Array.from(sectionsToFootnotes.keys());
            
            footnoteScroller
                .setup({
                    step: sectionsWithFootnotes,
                    offset: 0.6, // Trigger when section is 40% down from top
                    debug: false
                })
                .onStepEnter(response => {
                    const sectionFootnotes = sectionsToFootnotes.get(response.element);
                    if (sectionFootnotes) {
                        // Show footnotes for this section
                        sectionFootnotes.forEach(f => f.classList.add('visible'));
                    }
                })
                .onStepExit(response => {
                    const sectionFootnotes = sectionsToFootnotes.get(response.element);
                    if (sectionFootnotes) {
                        // Hide footnotes for this section when it leaves
                        sectionFootnotes.forEach(f => f.classList.remove('visible'));
                    }
                });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                footnoteScroller.resize();
                predictionScroller.resize();
            });
        };
        
        // Initialize footnotes after DOM is ready
        setupFootnotes();
        
        // Mobile controls functionality
        const setupMobileControls = () => {
            const toggleBtn = document.getElementById('mobile-controls-toggle');
            const closeBtn = document.getElementById('mobile-close-btn');
            const sidebar = document.getElementById('controls-sidebar');
            const overlay = document.getElementById('mobile-overlay');
            
            const openSidebar = () => {
                sidebar.classList.add('mobile-active', 'open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent body scroll
            };
            
            const closeSidebar = () => {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
                document.body.style.overflow = ''; // Restore body scroll
                
                // Remove mobile-active class after transition
                setTimeout(() => {
                    sidebar.classList.remove('mobile-active');
                }, 300);
            };
            
            // Toggle button click
            toggleBtn.addEventListener('click', openSidebar);
            
            // Close button click
            closeBtn.addEventListener('click', closeSidebar);
            
            // Overlay click
            overlay.addEventListener('click', closeSidebar);
            
            // Close on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && sidebar.classList.contains('open')) {
                    closeSidebar();
                }
            });
        };
        
        // Early Voting Scatterplot Functionality
        function initEarlyVotingScatterplot() {
            // Show loading indicator
            document.getElementById('early-voting-loading').style.display = 'block';
            
            // Fetch the early voting scatter data
            fetch('data/processed_data/early_votes_scatter_data.json')
                .then(response => response.json())
                .then(scatterData => {
                    // Hide loading indicator
                    document.getElementById('early-voting-loading').style.display = 'none';
                    
                    // Create the scatter plot
                    createEarlyVotingScatterPlot(scatterData.data);
                    
                    // Add event listeners for radio buttons
                    document.querySelectorAll('input[name="earlyVotingColorMode"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            createEarlyVotingScatterPlot(scatterData.data);
                        });
                    });
                })
                .catch(error => {
                    console.error('Error loading early voting data:', error);
                    document.getElementById('early-voting-loading').textContent = 'Error loading data. Please check console for details.';
                });
        }
        
        function createEarlyVotingScatterPlot(data) {
            // Get the selected color mode
            const colorMode = document.querySelector('input[name="earlyVotingColorMode"]:checked').value;
            
            // Process data for the plot
            const plotData = data.map(item => ({
                tabulator: item.tabulator,
                total_votes: item.total_votes,
                trump_percentage: item.trump_percentage,
                area_type: item.is_urban === true ? 'Urban' : 'Rural',
                urban_percentage: item.urban_percentage || 0
            }));
            
            // Create color scale configuration based on color mode
            let colorConfig = {};
            let dotConfig = {};
            
            if (colorMode === 'binary') {
                // Binary Urban/Rural coloring
                dotConfig = {
                    fill: d => d.area_type === 'Urban' ? "blue" : "green",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nArea: ${d.area_type}`
                };
            } else if (colorMode === 'gradient') {
                // Urban percentage gradient coloring
                colorConfig = {
                    scheme: "Cividis",
                    legend: true,
                    label: "Urban %",
                    pivot: 50,
                    domain: [0, 100]
                };
                dotConfig = {
                    stroke: "urban_percentage",
                    fill: "urban_percentage",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%\nUrban %: ${d.urban_percentage.toFixed(1)}%`
                };
            } else if (colorMode === 'cutoff800') {
                // Cut off at 800 votes with dual candidate display
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
                const kDotConfig = {
                    fill: "blue",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nKamala %: ${(100-d.trump_percentage).toFixed(2)}%`
                };
                
                // Add kamala percentage to data
                for (let i = 0; i < plotData.length; i++) {
                    plotData[i].kamala_percentage = 100 - plotData[i].trump_percentage;
                }
                
                const filteredPlotData = plotData.filter(d => d.total_votes < 800);
                
                // Create the scatter plot with dual candidates
                const plot = Plot.plot({
                    width: 800,
                    height: 500,
                    marginBottom: 50,
                    marginLeft: 60,
                    grid: true,
                    x: {
                        label: "Total Votes per Machine",
                        nice: true,
                        domain: [0, Math.max(...filteredPlotData.map(d => d.total_votes)) * 1.05]
                    },
                    y: {
                        label: "Vote %",
                        nice: true,
                        domain: [0, 100],
                        tickFormat: d => `${d.toFixed(0)}`,
                        grid: true
                    },
                    marks: [
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "trump_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...dotConfig
                        }),
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "kamala_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...kDotConfig
                        })
                    ]
                });
                
                // Clear and append the plot to the container
                const container = document.getElementById('early-voting-scatterplot');
                container.innerHTML = '';
                container.appendChild(plot);
                return;
            } else if (colorMode === 'cutoff125') {
                // Cut off at 125 votes with dual candidate display
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
                const kDotConfig = {
                    fill: "blue",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nKamala %: ${(100-d.trump_percentage).toFixed(2)}%`
                };
                
                // Add kamala percentage to data
                for (let i = 0; i < plotData.length; i++) {
                    plotData[i].kamala_percentage = 100 - plotData[i].trump_percentage;
                }
                
                const filteredPlotData = plotData.filter(d => d.total_votes < 125);
                
                // Create the scatter plot with dual candidates
                const plot = Plot.plot({
                    width: 800,
                    height: 500,
                    marginBottom: 50,
                    marginLeft: 60,
                    grid: true,
                    x: {
                        label: "Total Votes per Machine",
                        nice: true,
                        domain: [0, Math.max(...filteredPlotData.map(d => d.total_votes)) * 1.05]
                    },
                    y: {
                        label: "Vote %",
                        nice: true,
                        domain: [0, 100],
                        tickFormat: d => `${d.toFixed(0)}`,
                        grid: true
                    },
                    marks: [
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "trump_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...dotConfig
                        }),
                        Plot.dot(filteredPlotData, {
                            x: "total_votes",
                            y: "kamala_percentage",
                            r: 4,
                            opacity: 0.7,
                            ...kDotConfig
                        })
                    ]
                });
                
                // Clear and append the plot to the container
                const container = document.getElementById('early-voting-scatterplot');
                container.innerHTML = '';
                container.appendChild(plot);
                return;
            } else {
                // No coloring (red dots)
                dotConfig = {
                    fill: "red",
                    title: d => `Tabulator: ${d.tabulator}\nTotal Votes: ${d.total_votes}\nTrump %: ${d.trump_percentage.toFixed(2)}%`
                };
            }
            
            // Create the standard scatter plot
            const plot = Plot.plot({
                width: 800,
                height: 500,
                marginBottom: 50,
                marginLeft: 60,
                grid: true,
                color: colorMode === 'gradient' ? colorConfig : null,
                x: {
                    label: "Total Votes per Machine",
                    nice: true,
                    domain: [0, Math.max(...plotData.map(d => d.total_votes)) * 1.05]
                },
                y: {
                    label: "Trump %",
                    nice: true,
                    domain: [0, 100],
                    tickFormat: d => `${d.toFixed(0)}`,
                    grid: true
                },
                marks: [
                    Plot.dot(plotData, {
                        x: "total_votes",
                        y: "trump_percentage",
                        r: 4,
                        opacity: 0.7,
                        ...dotConfig
                    })
                ]
            });
            
            // Clear and append the plot to the container
            const container = document.getElementById('early-voting-scatterplot');
            container.innerHTML = '';
            container.appendChild(plot);
        }

        const earlyVotingPlotInitializer = scrollama();

        earlyVotingPlotInitializer
            .setup({
                step: document.querySelectorAll('#early-voting-scatterplot-viz'),
                offset: 0.1, // Trigger when section is 90% down the viewport
                threshold: 4,
                once: true,
            })
            .onStepEnter((response) => {
                if (response.index === 0) {
                    initEarlyVotingScatterplot();
                }
            });
        
        // Initialize mobile controls
        setupMobileControls();
    </script>
</body>
</html>
