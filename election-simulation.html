<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Election Data Convergence: What Does "Normal" Look Like?</title>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm" type="module"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            border-radius: 5px;
        }
        h1 {
            text-align: center;
            background-color: #FFD700; /* Gold background for header */
            color: #000;
            padding: 15px;
            margin-top: 0;
            border-radius: 4px;
        }
        h2 {
            color: #2c3e50;
        }
        .section {
            max-width: 900px;
            margin: 40px auto;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            border-radius: 5px;
        }
        .description {
            margin: 20px 0;
            line-height: 1.5;
            color: #333;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            display: inline-block;
            width: 200px;
            font-weight: 600;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4682B4;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4682B4;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            background: #5A8FCC;
        }
        
        input[type="range"]:active::-moz-range-thumb {
            background: #5A8FCC;
        }
        
        input[type="range"]:hover {
            background: #ccc;
        }
        
        input[type="number"] {
            width: 60px;
        }
        button {
            padding: 10px 20px;
            background: #4682B4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
            margin-top: 10px;
            align-self: center;
        }
        
        button:hover {
            background: #5A8FCC;
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        span {
            font-weight: 400;
            color: #555;
            width: 60px;
            display: inline-block;
            text-align: right;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .explanation {
            background: #e8f4f8;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }
        .warning {
            background: #ffeaa7;
            padding: 15px;
            border-left: 4px solid #fdcb6e;
            margin: 20px 0;
        }
        .key-point {
            background: #d1f2eb;
            padding: 15px;
            border-left: 4px solid #00b894;
            margin: 20px 0;
            font-weight: 600;
        }
    </style>
    
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WFVL4QQCXF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WFVL4QQCXF');
</script>

</head>
<body>
    <div class="container">
        <h1>Election Data Convergence: What Does "Normal" Look Like?</h1>
        
        <div class="description">
            <h2>Understanding Vote Percentage Convergence</h2>
            <p>When votes are counted sequentially, the running vote percentage naturally converges toward the true value. This is a fundamental property of statistics, not evidence of manipulation. Let's explore why.</p>
        </div>
        
        <div class="election-results" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #002051;">
            <h3 style="margin: 0 0 10px 0; color: #002051;">Actual Early Voting Results (Clark County)</h3>
            <div style="display: flex; gap: 30px; align-items: center;">
                <div><strong>Total Votes:</strong> 390,936</div>
                <div><strong>Trump:</strong> 60.0%</div>
                <div><strong>Harris:</strong> 40.0%</div>
                <div style="margin-left: auto; font-size: 12px; color: #666;">
                    Turnout: 51.9% Republicans | 27.8% Democrats | 20.3% Independents
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Urban Support Base:</label>
                <input type="range" id="urbanSupportBase" min="0" max="100" value="45" step="1">
                <span id="urbanSupportBaseValue">45%</span>
            </div>
            <div class="control-group">
                <label>Rural Support Base:</label>
                <input type="range" id="ruralSupportBase" min="0" max="100" value="73" step="1">
                <span id="ruralSupportBaseValue">73%</span>
            </div>
            <div class="control-group">
                <label>Suburban Support Base:</label>
                <input type="range" id="suburbanSupportBase" min="0" max="100" value="60" step="1">
                <span id="suburbanSupportBaseValue">60%</span>
            </div>
            <div class="control-group">
                <label>Rural Machines:</label>
                <input type="range" id="ruralMachines" min="0" max="500" value="250" step="10">
                <span id="ruralMachinesValue">250</span>
                <span style="font-size: 12px; color: #666; display: block;">Total: 964 | Non-rural: <span id="nonRuralCount">714</span></span>
            </div>
            <div class="control-group">
                <label>Urban % of Non-Rural Machines:</label>
                <input type="range" id="urbanPercentage" min="0" max="100" value="35" step="5">
                <span id="urbanPercentageValue">35%</span>
                <span style="font-size: 12px; color: #666; display: block;">Urban: <span id="urbanCount">214</span> | Suburban: <span id="suburbanCount">500</span> | Rural: <span id="ruralCountDisplay">250</span></span>
            </div>
            <div class="control-group">
                <label>Urban Cluster Variance:</label>
                <input type="range" id="urbanClusterStrength" min="1" max="20" value="10" step="1">
                <span id="urbanClusterStrengthValue">10</span>
            </div>
            <div class="control-group">
                <label>Suburban Cluster Variance:</label>
                <input type="range" id="suburbanClusterStrength" min="1" max="20" value="4" step="1">
                <span id="suburbanClusterStrengthValue">4</span>
            </div>
            <div class="control-group">
                <label>Rural Cluster Variance:</label>
                <input type="range" id="ruralClusterStrength" min="1" max="20" value="8" step="1">
                <span id="ruralClusterStrengthValue">8</span>
            </div>
            <button id="runSimulation">Run Simulation</button>
        </div>
        
        <div class="simulation-results" style="background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #27ae60; max-width: 300px;">
            <h3 style="margin: 0 0 10px 0; color: #27ae60;">Simulation Results</h3>
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <div><strong>Total Votes:</strong> <span id="simTotalVotes">0</span></div>
                <div><strong>Trump:</strong> <span id="simTrumpPercent">0.0%</span></div>
                <div><strong>Harris:</strong> <span id="simHarrisPercent">0.0%</span></div>
            </div>
        </div>
        
        <div class="chart-container" id="mainChart"></div>
        
        <div class="controls" style="margin: 20px 0;">
            <div class="control-group">
                <label>Histogram Display Mode:</label>
                <div class="radio-group" style="display: inline-flex; gap: 15px;">
                    <label><input type="radio" name="histogramDisplayMode" value="stacked" checked> Stacked</label>
                    <label><input type="radio" name="histogramDisplayMode" value="overlapping"> Overlapping</label>
                </div>
            </div>
            <div class="control-group" style="margin-left: 20px;">
                <label>Color Mode:</label>
                <div class="radio-group" style="display: inline-flex; gap: 15px;">
                    <label><input type="radio" name="histogramColorMode" value="ternary" checked> Urban/Suburban/Rural</label>
                    <label><input type="radio" name="histogramColorMode" value="binary"> Urban/Rural Combined</label>
                    <label><input type="radio" name="histogramColorMode" value="unary"> All Combined (Red)</label>
                </div>
            </div>
        </div>
        
        <div class="chart-container" id="histogramChart"></div>
        
        <div class="explanation">
            <strong>What you're seeing:</strong> Each point represents a voting machine. Machines are grouped into voting locations (clusters), with each location having its own true support rate.
            
            <p>We're modeling several real-world patterns:</p>
            <ul>
                <li><strong>Urban-Rural Divide:</strong> Urban locations (more Democratic-leaning) tend to have more machines but fewer votes per machine. Rural locations (more Republican-leaning) have fewer machines but more votes per machine.</li>
                <li><strong>Local Clustering:</strong> Machines in the same location have similar Trump support rates, creating clusters in the visualization.</li>
                <li><strong>Sampling Variability:</strong> Machines with fewer votes show more scatter from their location's true rate due to the Law of Large Numbers.</li>
            </ul>
            
            <p>These patterns create a more realistic simulation that better matches actual election data distributions.</p>
        </div>
    </div>
    
    <div class="section">
        <h2>Understanding the "Russian Tail"</h2>
        <p>A real "Russian tail" is a specific statistical anomaly seen in manipulated elections, where an unusual number of districts report extremely high vote percentages (often 90-100%). This is NOT the same as normal bimodal distributions or convergence patterns.</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Manipulation Level:</label>
                <input type="range" id="manipulationLevel" min="0" max="30" value="10" step="5">
                <span id="manipulationLevelValue">10%</span> of districts
            </div>
            <div class="control-group">
                <label>Display Mode:</label>
                <label style="width: auto; margin-left: 10px;">
                    <input type="radio" name="displayMode" value="stacked" checked> Stacked
                </label>
                <label style="width: auto; margin-left: 10px;">
                    <input type="radio" name="displayMode" value="overlapping"> Overlapping
                </label>
            </div>
            <button id="generateRussianTail">Generate Distribution</button>
        </div>
        
        <div class="chart-container" id="russianTailChart"></div>
        
        <div class="warning">
            <strong>Important:</strong> A bimodal distribution (two peaks) is NORMAL in elections due to urban/rural divides. A "Russian tail" is specifically a flat distribution at extreme values (80-95%), not just any peak at high percentages.
        </div>
    </div>
    
    <script type="module">
        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";
        import { createHistogram } from './src/histogram.js';
        // TODO
        // - Consider making an option to run the simulation as a full election, using 3115 total machines, each one topping out at most 125 votes, comparable turnout for D and R. 
        // - Add suburban as a population type. Let the mean for urban be 45%, suburban be 60%, and rural be 80%. 
        // - Add population effects. In early voting, Republicans were more likely to vote than democrats, democrats mostly voted on electino day or by mail. 

        /*
        Settings that produced a very similar image:
        urban base: 45
        rural base: 73
        suburban base: 60
        rural machines 250
        urban% of non rural machines 55 (so slightly more urban than suburbal)
        urban cluster variance: 11
        suburban cluster variance: 3
        rural cluster variance: 9
        */
        
        // State for simulations and generated data
        const simulation = {
            urbanSupportBase: 45,
            ruralSupportBase: 73,
            suburbanSupportBase: 60,
            urbanPercentage: 55,  // Percentage of non-rural machines that are urban
            urbanClusterStrength: 11,
            suburbanClusterStrength: 3,
            ruralClusterStrength: 9,
            // Fixed machine counts based on real election data
            ruralMachines: 250,
            nonRuralMachines: 714,
            totalMachines: 964,
            data: null
        };
        
        const russianTailSimulation = {
            manipulationLevel: 10,
            displayMode: 'overlapping',
            data: null
        };
        
        // Update value displays and handle realtime changes
        const urbanSupportBaseSlider = document.getElementById('urbanSupportBase');
        const ruralSupportBaseSlider = document.getElementById('ruralSupportBase');
        const suburbanSupportBaseSlider = document.getElementById('suburbanSupportBase');
        const ruralMachinesSlider = document.getElementById('ruralMachines');
        const urbanPercentageSlider = document.getElementById('urbanPercentage');
        const urbanClusterStrengthSlider = document.getElementById('urbanClusterStrength');
        const suburbanClusterStrengthSlider = document.getElementById('suburbanClusterStrength');
        const ruralClusterStrengthSlider = document.getElementById('ruralClusterStrength');
        const manipulationLevelSlider = document.getElementById('manipulationLevel');
        
        // Use both input (for realtime updates during drag) and change (for final value)
        urbanSupportBaseSlider.addEventListener('input', (e) => {
            simulation.urbanSupportBase = parseInt(e.target.value);
            document.getElementById('urbanSupportBaseValue').textContent = e.target.value + '%';
            // Only redraw charts, don't regenerate data
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        ruralSupportBaseSlider.addEventListener('input', (e) => {
            simulation.ruralSupportBase = parseInt(e.target.value);
            document.getElementById('ruralSupportBaseValue').textContent = e.target.value + '%';
            // Only redraw charts, don't regenerate data
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        suburbanSupportBaseSlider.addEventListener('input', (e) => {
            simulation.suburbanSupportBase = parseInt(e.target.value);
            document.getElementById('suburbanSupportBaseValue').textContent = e.target.value + '%';
            // Only redraw charts, don't regenerate data
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        ruralMachinesSlider.addEventListener('input', (e) => {
            simulation.ruralMachines = parseInt(e.target.value);
            simulation.nonRuralMachines = simulation.totalMachines - simulation.ruralMachines;
            document.getElementById('ruralMachinesValue').textContent = e.target.value;
            document.getElementById('nonRuralCount').textContent = simulation.nonRuralMachines;
            document.getElementById('ruralCountDisplay').textContent = simulation.ruralMachines;
            
            // Recalculate urban/suburban split
            const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
            const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
            document.getElementById('urbanCount').textContent = urbanMachines;
            document.getElementById('suburbanCount').textContent = suburbanMachines;
            // This affects data generation, so we don't redraw here
        });
        
        urbanPercentageSlider.addEventListener('input', (e) => {
            simulation.urbanPercentage = parseInt(e.target.value);
            document.getElementById('urbanPercentageValue').textContent = e.target.value + '%';
            
            // Calculate and display machine counts
            const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
            const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
            document.getElementById('urbanCount').textContent = urbanMachines;
            document.getElementById('suburbanCount').textContent = suburbanMachines;
            // This affects data generation, so we don't redraw here
        });
        
        urbanClusterStrengthSlider.addEventListener('input', (e) => {
            simulation.urbanClusterStrength = parseInt(e.target.value);
            document.getElementById('urbanClusterStrengthValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        suburbanClusterStrengthSlider.addEventListener('input', (e) => {
            simulation.suburbanClusterStrength = parseInt(e.target.value);
            document.getElementById('suburbanClusterStrengthValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        ruralClusterStrengthSlider.addEventListener('input', (e) => {
            simulation.ruralClusterStrength = parseInt(e.target.value);
            document.getElementById('ruralClusterStrengthValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        manipulationLevelSlider.addEventListener('input', (e) => {
            russianTailSimulation.manipulationLevel = parseInt(e.target.value);
            document.getElementById('manipulationLevelValue').textContent = e.target.value + '%';
            // Regenerate and redraw Russian tail data immediately
            russianTailSimulation.data = generateRussianTailData();
            drawRussianTailChart();
        });
        
        document.querySelectorAll('input[name="displayMode"]').forEach((input) => {
            input.addEventListener('change', (e) => {
                russianTailSimulation.displayMode = e.target.value;
                // Only redraw, don't regenerate data
                drawRussianTailChart();
            });
        });
        
        // Add event listeners for histogram controls
        document.querySelectorAll('input[name="histogramDisplayMode"], input[name="histogramColorMode"]').forEach(input => {
            input.addEventListener('change', () => {
                if (simulation.data) {
                    drawHistogram(simulation.data);
                }
            });
        });
        
        // Generate election data
        function generateElectionData() {
            const data = [];
            const urbanSupportBase = simulation.urbanSupportBase / 100;
            const ruralSupportBase = simulation.ruralSupportBase / 100;
            const suburbanSupportBase = simulation.suburbanSupportBase / 100;
            
            // Calculate actual machine counts
            const urbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
            const suburbanMachines = simulation.nonRuralMachines - urbanMachines;
            const ruralMachines = simulation.ruralMachines;
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate vote count distribution - right-skewed with long tail
            function generateVoteCount(locationType) {
                // Log-normal with different mu, sigma for urban/rural
                // These values create distributions matching observed data
                if (locationType === "Urban") {
                    const mu = 5.5;  // Mean of log
                    const sigma = 0.4;  // Std dev of log
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                } else if (locationType === "Suburban") {
                    const mu = 5.85;  // Mean of log
                    const sigma = 0.45;  // Std dev of log
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                } else {
                    const mu = 6.1;  // Higher mean for rural
                    const sigma = 0.35;  // Different spread
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                }
            }
            
            // Group machines by polling locations (3-5 machines per location)
            function generateMachinesForLocationType(numMachines, locationType, supportBase, clusterStrength, startIndex) {
                const machines = [];
                let machineIndex = 0;
                
                while (machineIndex < numMachines) {
                    // Determine number of machines at this polling location (3-5)
                    const machinesAtLocation = Math.min(numMachines - machineIndex, 
                        Math.floor(Math.random() * 3) + 3);
                    
                    // Generate base vote count for this polling location
                    const baseVoteCount = generateVoteCount(locationType);
                    
                    // Generate cluster support rate for this location
                    const clusterMean = supportBase;
                    const clusterStdDev = clusterStrength / 100;
                    const locationSupportRate = normalRandom(clusterMean, clusterStdDev);
                    
                    // Generate machines at this location with similar vote counts
                    for (let j = 0; j < machinesAtLocation; j++) {
                        // Vary vote count by ±10% from base
                        const voteVariation = 0.9 + Math.random() * 0.2;
                        const voteCount = Math.round(baseVoteCount * voteVariation);
                        
                        let trumpVotes = 0;
                        for (let voter = 0; voter < voteCount; voter++) {
                            if (Math.random() < locationSupportRate) {
                                trumpVotes++;
                            }
                        }
                        
                        const trumpPercentage = voteCount > 0 ? (trumpVotes / voteCount) * 100 : 0;
                        
                        machines.push({
                            location: startIndex + machineIndex + j,
                            totalVotes: voteCount,
                            trumpPercentage: trumpPercentage,
                            trumpVotes: trumpVotes,
                            supportRate: locationSupportRate * 100,
                            locationType: locationType
                        });
                    }
                    
                    machineIndex += machinesAtLocation;
                }
                
                return machines;
            }
            
            // Generate machines for each location type
            const urbanData = generateMachinesForLocationType(urbanMachines, "Urban", urbanSupportBase, simulation.urbanClusterStrength, 0);
            const suburbanData = generateMachinesForLocationType(suburbanMachines, "Suburban", suburbanSupportBase, simulation.suburbanClusterStrength, urbanMachines);
            const ruralData = generateMachinesForLocationType(ruralMachines, "Rural", ruralSupportBase, simulation.ruralClusterStrength, urbanMachines + suburbanMachines);
            
            // Combine all data
            data.push(...urbanData, ...suburbanData, ...ruralData);
            
            return data;
        }
        
        // Draw main chart using Observable Plot
        function drawMainChart(data) {
            if (!data || data.length === 0) return;
            const chart = Plot.plot({
                width: 800,
                height: 500,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Total Votes per Machine →",
                    grid: true,
                    domain: [1, 1250]
                },
                y: {
                    label: "↑ Trump %",
                    domain: [0, 100],
                    grid: true
                },
                color: {
                    type: "categorical",
                    domain: ["Urban", "Suburban", "Rural"],
                    range: ["#FDEA45", "#808080", "#002051"],
                    label: "Location Type",
                    legend: true
                },
                marks: [
                    Plot.dot(data, {
                        x: "totalVotes",
                        y: "trumpPercentage",
                        fill: "locationType", // Use locationType for coloring
                        stroke: "gray",
                        strokeWidth: 0.5,
                        r: 3.5,
                        opacity: 0.7,
                        title: d => `Location ${d.location}, Machine ${d.machine}\nVotes: ${d.totalVotes}, Trump: ${d.trumpPercentage.toFixed(1)}%`
                    }),
                    Plot.ruleY([simulation.urbanSupportBase], {
                        stroke: "#FDEA45",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleY([simulation.suburbanSupportBase], {
                        stroke: "#808080",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleY([simulation.ruralSupportBase], {
                        stroke: "#002051",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.text([{x: 1150, y: simulation.urbanSupportBase || 45}], {
                        text: ["Urban: " + (simulation.urbanSupportBase || 45) + "%"],
                        fill: "#FDEA45",
                        fontSize: 12,
                        dx: 0
                    }),
                    Plot.text([{x: 1150, y: simulation.suburbanSupportBase || 60}], {
                        text: ["Suburban: " + (simulation.suburbanSupportBase || 60) + "%"],
                        fill: "#808080",
                        fontSize: 12,
                        dx: 0
                    }),
                    Plot.text([{x: 1150, y: simulation.ruralSupportBase || 80}], {
                        text: ["Rural: " + (simulation.ruralSupportBase || 80) + "%"],
                        fill: "#002051",
                        fontSize: 12,
                        dx: 0
                    })
                ]
            });
            
            document.getElementById('mainChart').innerHTML = '';
            document.getElementById('mainChart').appendChild(chart);
        }
        
        // Draw histogram
        function drawHistogram(data) {
            if (!data || data.length === 0) return;
            
            // Get current settings
            const displayMode = document.querySelector('input[name="histogramDisplayMode"]:checked')?.value || 'stacked';
            const colorMode = document.querySelector('input[name="histogramColorMode"]:checked')?.value || 'ternary';
            
            // Transform data to match expected format
            const transformedData = data.map(d => ({
                trumpPercentage: d.trumpPercentage,
                trump_percentage: d.trumpPercentage,
                locationType: d.locationType,
                urban_percentage: d.locationType === 'Urban' ? 100 : (d.locationType === 'Suburban' ? 50 : 0)
            }));
            
            // Prepare reference lines for the simulation's support bases
            const referenceLines = [
                { value: simulation.urbanSupportBase, color: '#FDEA45' },
                { value: simulation.suburbanSupportBase, color: '#808080' },
                { value: simulation.ruralSupportBase, color: '#002051' }
            ];
            
            // Use the histogram module
            const container = document.getElementById('histogramChart');
            container.innerHTML = '';
            createHistogram(container, transformedData, {
                displayMode,
                colorMode,
                title: 'Distribution of Trump Vote % by Machine',
                referenceLines: colorMode === 'ternary' ? referenceLines : null
            });
        }

        
        // Russian tail simulation
        function generateRussianTailData() {
            const districts = 2000;
            const manipulations = Math.floor(districts * (russianTailSimulation.manipulationLevel / 100));
            const data = [];
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate normal distributions for non-manipulated districts
            const urbanCount = Math.floor((districts - manipulations) * 0.4);
            const ruralCount = (districts - manipulations) - urbanCount;
            
            // Urban districts - normal distribution centered around 35%
            for (let i = 0; i < urbanCount; i++) {
                let votePercentage = normalRandom(35, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: i, 
                    votePercentage: votePercentage, 
                    type: 'Urban'
                });
            }
            
            // Rural districts - normal distribution centered around 65%
            for (let i = 0; i < ruralCount; i++) {
                let votePercentage = normalRandom(65, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: urbanCount + i, 
                    votePercentage: votePercentage, 
                    type: 'Rural'
                });
            }
            
            // Add manipulated districts (gradually decreasing tail all the way to 100%)
            for (let location = 0; location < manipulations; location++) {
                const randomValue = Math.random();
                let votePercentage;
                
                // Distributing values in specified ranges:
                if (randomValue < 0.6) {
                    // 60% of manipulated districts between 80-90%
                    votePercentage = 80 + ((randomValue) / 0.6) * 10;
                } else if (randomValue < 0.85) {
                    // 25% of manipulated districts between 90-95%
                    votePercentage = 90 + ((randomValue - 0.6) / 0.25) * 5;
                } else if (randomValue < 0.95) {
                    // 10% of manipulated districts between 95-99%
                    votePercentage = 95 + ((randomValue - 0.85) / 0.1) * 4;
                } else {
                    // 5% of manipulated districts between 99-100% (including some at exactly 100%)
                    votePercentage = 99 + ((randomValue - 0.95) / 0.05) * 1;
                }
                
                data.push({
                    district: districts - manipulations + location,
                    votePercentage: votePercentage,
                    type: 'Manipulated'
                });
            }
            
            return data;
        }
        
        // Draw Russian tail chart
        function drawRussianTailChart() {
            const data = russianTailSimulation.data;
            if (!data || data.length === 0) return;
            
            // For overlapping mode, combine manipulated with rural
            const dataForOverlapping = russianTailSimulation.displayMode === 'overlapping' 
                ? data.map(d => ({
                    ...d,
                    type: d.type === 'Manipulated' ? 'Rural' : d.type
                  }))
                : data;
            
            const marks = russianTailSimulation.displayMode === 'stacked' 
                ? [
                    Plot.rectY(data, Plot.binX({y: "count"}, {
                        x: "votePercentage",
                        fill: "type",
                        mixBlendMode: "normal",
                        thresholds: 50
                    })),
                    Plot.ruleY([0])
                  ]
                : [
                    Plot.rectY(dataForOverlapping.filter(d => d.type === 'Urban'), Plot.binX({y2: "count"}, {
                        x: "votePercentage",
                        fill: "#FDEA45",
                        fillOpacity: 0.5,
                        thresholds: 50
                    })),
                    Plot.rectY(dataForOverlapping.filter(d => d.type === 'Rural'), Plot.binX({y2: "count"}, {
                        x: "votePercentage",
                        fill: "#002051",
                        fillOpacity: 0.5,
                        thresholds: 50
                    })),
                    Plot.ruleY([0])
                  ];
            
            const chart = Plot.plot({
                width: 900,
                height: 500,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Vote Percentage for Candidate →",
                    domain: [0, 100]
                },
                y: {
                    label: "↑ Number of Districts"
                },
                color: russianTailSimulation.displayMode === 'stacked' ? {
                    legend: true,
                    domain: ["Urban", "Rural", "Manipulated"],
                    range: ["#FDEA45", "#002051", "#e74c3c"]
                } : undefined,
                marks: marks
            });
            
            // Add legend and annotation for overlapping mode
            if (russianTailSimulation.displayMode === 'overlapping') {
                const legendData = [
                    {x: 780, y: 30, label: "Urban", color: "#FDEA45"},
                    {x: 780, y: 50, label: "Rural + Manipulated", color: "#002051"}
                ];
                
                const annotationMarks = russianTailSimulation.manipulationLevel > 0 ? [
                    Plot.rect([{x1: 80, x2: 100, y1: 0, y2: 100}], {
                        x1: "x1",
                        x2: "x2", 
                        y1: "y1",
                        y2: "y2",
                        fill: "#e74c3c",
                        fillOpacity: 0.1
                    }),
                    Plot.text([{x: 90, y: 80, text: "Russian Tail"}], {
                        x: "x",
                        y: "y",
                        text: "text",
                        fill: "#e74c3c",
                        fontSize: 14,
                        fontWeight: "bold",
                        textAnchor: "middle"
                    })
                ] : [];
                
                const legendChart = Plot.plot({
                    width: 900,
                    height: 500,
                    marginLeft: 50, 
                    marginRight: 100, 
                    marginTop: 20, 
                    marginBottom: 50,
                    x: {
                        label: "Vote Percentage for Candidate →",
                        domain: [0, 100]
                    },
                    y: {
                        label: "↑ Number of Districts"
                    },
                    marks: [
                        ...annotationMarks,
                        ...marks,
                        Plot.dot(legendData, {
                            x: "x",
                            y: "y",
                            r: 6,
                            fill: "color"
                        }),
                        Plot.text(legendData, {
                            x: d => d.x + 15,
                            y: "y",
                            text: "label",
                            textAnchor: "start",
                            dy: 3
                        })
                    ]
                });
                
                document.getElementById('russianTailChart').replaceChildren(legendChart);
                return;
            }
            
            document.getElementById('russianTailChart').replaceChildren(chart);
        }
        
        // Update simulation results display
        function updateSimulationResults(data) {
            const totalVotes = data.reduce((sum, d) => sum + d.totalVotes, 0);
            const totalTrumpVotes = data.reduce((sum, d) => sum + d.trumpVotes, 0);
            const trumpPercent = totalVotes > 0 ? (totalTrumpVotes / totalVotes * 100) : 0;
            const harrisPercent = 100 - trumpPercent;
            
            document.getElementById('simTotalVotes').textContent = totalVotes.toLocaleString();
            document.getElementById('simTrumpPercent').textContent = trumpPercent.toFixed(1) + '%';
            document.getElementById('simHarrisPercent').textContent = harrisPercent.toFixed(1) + '%';
        }
        
        // Event listeners
        document.getElementById('runSimulation').addEventListener('click', () => {
            simulation.data = generateElectionData();
            updateSimulationResults(simulation.data);
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        // document.getElementById('runCoinFlip').addEventListener('click', runCoinFlipSimulation);
        document.getElementById('generateRussianTail').addEventListener('click', () => {
            russianTailSimulation.data = generateRussianTailData();
            drawRussianTailChart();
        });
        
        // Initialize machine count display
        const initialUrbanMachines = Math.round(simulation.nonRuralMachines * (simulation.urbanPercentage / 100));
        const initialSuburbanMachines = simulation.nonRuralMachines - initialUrbanMachines;
        document.getElementById('urbanCount').textContent = initialUrbanMachines;
        document.getElementById('suburbanCount').textContent = initialSuburbanMachines;
        document.getElementById('nonRuralCount').textContent = simulation.nonRuralMachines;
        document.getElementById('ruralCountDisplay').textContent = simulation.ruralMachines;
        
        // Initial draw
        simulation.data = generateElectionData();
        updateSimulationResults(simulation.data);
        drawMainChart(simulation.data);
        drawHistogram(simulation.data);
        russianTailSimulation.data = generateRussianTailData();
        drawRussianTailChart();
    </script>
</body>
</html>
