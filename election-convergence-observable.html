<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Election Data Convergence: What Does "Normal" Look Like?</title>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm" type="module"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .section {
            margin: 40px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .controls {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 200px;
            font-weight: 600;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            background: #2980b9;
        }
        
        input[type="range"]:active::-moz-range-thumb {
            background: #2980b9;
        }
        
        input[type="range"]:hover {
            background: #ccc;
        }
        
        input[type="number"] {
            width: 60px;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background: #2980b9;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .explanation {
            background: #e8f4f8;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }
        .warning {
            background: #ffeaa7;
            padding: 15px;
            border-left: 4px solid #fdcb6e;
            margin: 20px 0;
        }
        .key-point {
            background: #d1f2eb;
            padding: 15px;
            border-left: 4px solid #00b894;
            margin: 20px 0;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <h1>Election Data Convergence: What Does "Normal" Look Like?</h1>
    
    <div class="section">
        <h2>Understanding Vote Percentage Convergence</h2>
        <p>When votes are counted sequentially, the running vote percentage naturally converges toward the true value. This is a fundamental property of statistics, not evidence of manipulation. Let's explore why.</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Democrat Support Base:</label>
                <input type="range" id="demSupportBase" min="25" max="45" value="35" step="1">
                <span id="demSupportBaseValue">35%</span>
            </div>
            <div class="control-group">
                <label>Republican Support Base:</label>
                <input type="range" id="repSupportBase" min="55" max="75" value="65" step="1">
                <span id="repSupportBaseValue">65%</span>
            </div>
            <div class="control-group">
                <label>Dem/Urban Locations %:</label>
                <input type="range" id="urbanPercentage" min="30" max="70" value="60" step="5">
                <span id="urbanPercentageValue">60%</span>
            </div>
            <div class="control-group">
                <label>Cluster Strength:</label>
                <input type="range" id="clusterStrength" min="1" max="20" value="8" step="1">
                <span id="clusterStrengthValue">8</span>
            </div>
            <div class="control-group">
                <label>Total Locations:</label>
                <input type="range" id="numLocations" min="10" max="500" value="150" step="10">
                <span id="numLocationsValue">150</span>
            </div>
            <button id="runSimulation">Run Simulation</button>
        </div>
        
        <div class="chart-container" id="mainChart"></div>
        
        <div class="chart-container" id="histogramChart"></div>
        
        <div class="explanation">
            <strong>What you're seeing:</strong> Each point represents a voting machine. Machines are grouped into voting locations (clusters), with each location having its own true support rate.
            
            <p>We're modeling several real-world patterns:</p>
            <ul>
                <li><strong>Urban-Rural Divide:</strong> Urban locations (more Democratic-leaning) tend to have more machines but fewer votes per machine. Rural locations (more Republican-leaning) have fewer machines but more votes per machine.</li>
                <li><strong>Local Clustering:</strong> Machines in the same location have similar Trump support rates, creating clusters in the visualization.</li>
                <li><strong>Sampling Variability:</strong> Machines with fewer votes show more scatter from their location's true rate due to the Law of Large Numbers.</li>
            </ul>
            
            <p>These patterns create a more realistic simulation that better matches actual election data distributions.</p>
        </div>
    </div>
    
    <div class="section">
        <h2>Coin Flip Demonstration</h2>
        <p>To understand why convergence is normal, let's look at a simpler example: coin flips.</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Coins per Group:</label>
                <input type="range" id="coinsPerGroup" min="10" max="1000" value="100" step="10">
                <span id="coinsPerGroupValue">100</span>
            </div>
            <button id="runCoinFlip">Flip Coins</button>
        </div>
        
        <div class="chart-container" id="coinFlipChart"></div>
        <div id="coinFlipVariance" style="text-align: center; font-size: 18px; margin: 10px;"></div>
        
        <div class="key-point">
            Small samples have high variance. Large samples converge to the true value. This is why early vote counts can seem "wild" but later counts are more stable.
        </div>
    </div>
    
    <div class="section">
        <h2>Understanding the "Russian Tail"</h2>
        <p>A real "Russian tail" is a specific statistical anomaly seen in manipulated elections, where an unusual number of districts report extremely high vote percentages (often 90-100%). This is NOT the same as normal bimodal distributions or convergence patterns.</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Manipulation Level:</label>
                <input type="range" id="manipulationLevel" min="0" max="30" value="10" step="5">
                <span id="manipulationLevelValue">10%</span> of districts
            </div>
            <div class="control-group">
                <label>Display Mode:</label>
                <label style="width: auto; margin-left: 10px;">
                    <input type="radio" name="displayMode" value="stacked" checked> Stacked
                </label>
                <label style="width: auto; margin-left: 10px;">
                    <input type="radio" name="displayMode" value="overlapping"> Overlapping
                </label>
            </div>
            <button id="generateRussianTail">Generate Distribution</button>
        </div>
        
        <div class="chart-container" id="russianTailChart"></div>
        
        <div class="warning">
            <strong>Important:</strong> A bimodal distribution (two peaks) is NORMAL in elections due to urban/rural divides. A "Russian tail" is specifically a flat distribution at extreme values (80-95%), not just any peak at high percentages.
        </div>
    </div>
    
    <script type="module">
        import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";
        
        // State for simulations and generated data
        const simulation = {
            demSupportBase: 35,
            repSupportBase: 65,
            urbanPercentage: 60,
            clusterStrength: 8,
            numLocations: 150,
            data: null
        };
        
        const coinFlipSimulation = {
            coinsPerGroup: 100,
            data: null
        };
        
        const russianTailSimulation = {
            manipulationLevel: 10,
            displayMode: 'overlapping',
            data: null
        };
        
        // Update value displays and handle realtime changes
        const demSupportBaseSlider = document.getElementById('demSupportBase');
        const repSupportBaseSlider = document.getElementById('repSupportBase');
        const urbanPercentageSlider = document.getElementById('urbanPercentage');
        const clusterStrengthSlider = document.getElementById('clusterStrength');
        const numLocationsSlider = document.getElementById('numLocations');
        const coinsPerGroupSlider = document.getElementById('coinsPerGroup');
        const manipulationLevelSlider = document.getElementById('manipulationLevel');
        
        // Use both input (for realtime updates during drag) and change (for final value)
        demSupportBaseSlider.addEventListener('input', (e) => {
            simulation.demSupportBase = parseInt(e.target.value);
            document.getElementById('demSupportBaseValue').textContent = e.target.value + '%';
            // Only redraw charts, don't regenerate data
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        repSupportBaseSlider.addEventListener('input', (e) => {
            simulation.repSupportBase = parseInt(e.target.value);
            document.getElementById('repSupportBaseValue').textContent = e.target.value + '%';
            // Only redraw charts, don't regenerate data
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        urbanPercentageSlider.addEventListener('input', (e) => {
            simulation.urbanPercentage = parseInt(e.target.value);
            document.getElementById('urbanPercentageValue').textContent = e.target.value + '%';
            // This affects data generation, so we don't redraw here
        });
        
        clusterStrengthSlider.addEventListener('input', (e) => {
            simulation.clusterStrength = parseInt(e.target.value);
            document.getElementById('clusterStrengthValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        numLocationsSlider.addEventListener('input', (e) => {
            simulation.numLocations = parseInt(e.target.value);
            document.getElementById('numLocationsValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        coinsPerGroupSlider.addEventListener('input', (e) => {
            coinFlipSimulation.coinsPerGroup = parseInt(e.target.value);
            document.getElementById('coinsPerGroupValue').textContent = e.target.value;
            // This affects data generation, so we don't redraw here
        });
        
        manipulationLevelSlider.addEventListener('input', (e) => {
            russianTailSimulation.manipulationLevel = parseInt(e.target.value);
            document.getElementById('manipulationLevelValue').textContent = e.target.value + '%';
            // Regenerate and redraw Russian tail data immediately
            russianTailSimulation.data = generateRussianTailData();
            drawRussianTailChart();
        });
        
        document.querySelectorAll('input[name="displayMode"]').forEach((input) => {
            input.addEventListener('change', (e) => {
                russianTailSimulation.displayMode = e.target.value;
                // Only redraw, don't regenerate data
                drawRussianTailChart();
            });
        });
        
        // Generate election data
        function generateElectionData() {
            const data = [];
            const locations = simulation.numLocations;
            const demSupportBase = simulation.demSupportBase / 100;
            const repSupportBase = simulation.repSupportBase / 100;
            const urbanPercentage = simulation.urbanPercentage / 100;
            const clusterStrength = simulation.clusterStrength;
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate vote count distribution - right-skewed with long tail
            function generateVoteCount(locationType) {
                // Log-normal with different mu, sigma for urban/rural
                // These values create distributions matching observed data
                if (locationType === "Urban") {
                    const mu = 5.5;  // Mean of log
                    const sigma = 0.4;  // Std dev of log
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                } else {
                    const mu = 6.1;  // Higher mean for rural
                    const sigma = 0.35;  // Different spread
                    return Math.min(1200, Math.round(Math.exp(normalRandom(mu, sigma))));
                }
            }
            
            for (let location = 0; location < locations; location++) {
                // Step 1: Determine if this is an urban or rural location
                const locationType = Math.random() < urbanPercentage ? "Urban" : "Rural";
                const supportRate = locationType === "Urban" ? demSupportBase : repSupportBase;
                
                // Add cluster variation to the support rate
                const clusterMean = supportRate;
                const clusterStdDev = clusterStrength / 100;
                const locationSupportRate = normalRandom(clusterMean, clusterStdDev);
                
                // Urban locations tend to have more machines but fewer votes per machine
                // Rural locations tend to have fewer machines but more votes per machine
                const machinesInLocation = locationType === "Urban" ? 
                    Math.floor(normalRandom(7, 2)) : // More machines in urban areas
                    Math.floor(normalRandom(3, 1));  // Fewer machines in rural areas
                    
                // Ensure at least 1 machine per location
                const numMachines = Math.max(1, machinesInLocation);
                
                for (let machine = 0; machine < numMachines; machine++) {
                    // Step 2: Generate how many votes this machine will count
                    const voteCount = generateVoteCount(locationType);
                    
                    // Step 3: Simulate individual votes using the SAME probability for every vote
                    // The Law of Large Numbers will naturally emerge from this
                    let trumpVotes = 0;
                    
                    for (let voter = 0; voter < voteCount; voter++) {
                        // Every voter at this machine has exactly the same probability
                        // This lets the variance naturally decrease with sample size
                        if (Math.random() < locationSupportRate) {
                            trumpVotes++;
                        }
                    }
                    
                    // Calculate final percentage (avoid division by zero)
                    const trumpPercentage = voteCount > 0 ? (trumpVotes / voteCount) * 100 : 0;
                    
                    // Record the result for this machine
                    data.push({
                        location: location,
                        machine: machine,
                        totalVotes: voteCount,
                        trumpPercentage: trumpPercentage,
                        trumpVotes: trumpVotes,
                        supportRate: locationSupportRate * 100, // The machine's true probability
                        locationType: locationType,
                        color: locationType === "Urban" ? "#3498db" : "#e74c3c" // Color coding for urban/rural
                    });
                }
            }
            
            return data;
        }
        
        // Draw main chart using Observable Plot
        function drawMainChart(data) {
            if (!data || data.length === 0) return;
            const chart = Plot.plot({
                width: 800,
                height: 500,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Total Votes per Machine →",
                    grid: true,
                    domain: [1, 1250]
                },
                y: {
                    label: "↑ Trump %",
                    domain: [0, 100],
                    grid: true
                },
                color: {
                    type: "categorical",
                    domain: ["Urban", "Rural"],
                    range: ["#3498db", "#e74c3c"],
                    label: "Location Type",
                    legend: true
                },
                marks: [
                    Plot.dot(data, {
                        x: "totalVotes",
                        y: "trumpPercentage",
                        fill: "locationType", // Use locationType for coloring
                        stroke: "gray",
                        strokeWidth: 0.5,
                        r: 3.5,
                        opacity: 0.7,
                        title: d => `Location ${d.location}, Machine ${d.machine}\nVotes: ${d.totalVotes}, Trump: ${d.trumpPercentage.toFixed(1)}%`
                    }),
                    Plot.ruleY([simulation.demSupportBase], {
                        stroke: "blue",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleY([simulation.repSupportBase], {
                        stroke: "red",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.text([{x: 1150, y: simulation.demSupportBase || 35}], {
                        text: ["Dem Base: " + (simulation.demSupportBase || 35) + "%"],
                        fill: "blue",
                        fontSize: 12,
                        dx: 0
                    }),
                    Plot.text([{x: 1150, y: simulation.repSupportBase || 65}], {
                        text: ["Rep Base: " + (simulation.repSupportBase || 65) + "%"],
                        fill: "red",
                        fontSize: 12,
                        dx: 0
                    })
                ]
            });
            
            document.getElementById('mainChart').innerHTML = '';
            document.getElementById('mainChart').appendChild(chart);
        }
        
        // Draw histogram
        function drawHistogram(data) {
            if (!data || data.length === 0) return;
            console.log(data);
            const chart = Plot.plot({
                title: "Distribution of Trump Vote % by Machine",
                width: 800,
                height: 400,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Trump Percentage →",
                    domain: [0, 100]
                },
                y: {
                    label: "↑ Number of Machines"
                },
                marks: [
                    Plot.rectY(data, Plot.binX({y: "count"}, {
                        x: "trumpPercentage",
                        fill: "#3498db",
                        opacity: 0.8,
                        thresholds: 50
                    })),
                    Plot.ruleY([0]),
                    Plot.ruleX([simulation.demSupportBase], {
                        stroke: "blue",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    }),
                    Plot.ruleX([simulation.repSupportBase], {
                        stroke: "red",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    })
                ]
            });
            
            document.getElementById('histogramChart').innerHTML = '';
            document.getElementById('histogramChart').appendChild(chart);
        }
        
        // Coin flip simulation
        function runCoinFlipSimulation() {
            const groups = 100;
            const coinsPerGroup = coinFlipSimulation.coinsPerGroup;
            const data = [];
            
            for (let i = 0; i < groups; i++) {
                let heads = 0;
                for (let j = 0; j < coinsPerGroup; j++) {
                    if (Math.random() < 0.5) heads++;
                }
                data.push({
                    group: i,
                    headsPercentage: (heads / coinsPerGroup) * 100
                });
            }
            
            // Store the generated data
            coinFlipSimulation.data = data;
            
            const chart = Plot.plot({
                width: 800,
                height: 400,
                margin: 60,
                x: {
                    label: "Heads Percentage →",
                    domain: [0, 100]
                },
                y: {
                    label: "↑ Number of Groups"
                },
                marks: [
                    Plot.rectY(data, Plot.binX({y: "count"}, {
                        x: "headsPercentage",
                        fill: "#e74c3c",
                        thresholds: 20
                    })),
                    Plot.ruleY([0]),
                    Plot.ruleX([50], {
                        stroke: "black",
                        strokeWidth: 2,
                        strokeDasharray: "5,5"
                    })
                ]
            });
            
            document.getElementById('coinFlipChart').replaceChildren(chart);
            
            // Calculate and display variance
            const mean = data.reduce((sum, d) => sum + d.headsPercentage, 0) / groups;
            const variance = data.reduce((sum, d) => sum + Math.pow(d.headsPercentage - mean, 2), 0) / groups;
            const stdDev = Math.sqrt(variance);
            
            document.getElementById('coinFlipVariance').innerHTML = 
                `Standard Deviation: ${stdDev.toFixed(2)}% (smaller groups = more variance)`;
        }
        
        // Russian tail simulation
        function generateRussianTailData() {
            const districts = 2000;
            const manipulations = Math.floor(districts * (russianTailSimulation.manipulationLevel / 100));
            const data = [];
            
            // Box-Muller transform for normal distribution
            function normalRandom(mean, stdDev) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                return z0 * stdDev + mean;
            }
            
            // Generate normal distributions for non-manipulated districts
            const urbanCount = Math.floor((districts - manipulations) * 0.4);
            const ruralCount = (districts - manipulations) - urbanCount;
            
            // Urban districts - normal distribution centered around 35%
            for (let i = 0; i < urbanCount; i++) {
                let votePercentage = normalRandom(35, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: i, 
                    votePercentage: votePercentage, 
                    type: 'Urban'
                });
            }
            
            // Rural districts - normal distribution centered around 65%
            for (let i = 0; i < ruralCount; i++) {
                let votePercentage = normalRandom(65, 8);
                votePercentage = Math.max(0, Math.min(100, votePercentage));
                data.push({ 
                    district: urbanCount + i, 
                    votePercentage: votePercentage, 
                    type: 'Rural'
                });
            }
            
            // Add manipulated districts (gradually decreasing tail all the way to 100%)
            for (let location = 0; location < manipulations; location++) {
                const randomValue = Math.random();
                let votePercentage;
                
                // Distributing values in specified ranges:
                if (randomValue < 0.6) {
                    // 60% of manipulated districts between 80-90%
                    votePercentage = 80 + ((randomValue) / 0.6) * 10;
                } else if (randomValue < 0.85) {
                    // 25% of manipulated districts between 90-95%
                    votePercentage = 90 + ((randomValue - 0.6) / 0.25) * 5;
                } else if (randomValue < 0.95) {
                    // 10% of manipulated districts between 95-99%
                    votePercentage = 95 + ((randomValue - 0.85) / 0.1) * 4;
                } else {
                    // 5% of manipulated districts between 99-100% (including some at exactly 100%)
                    votePercentage = 99 + ((randomValue - 0.95) / 0.05) * 1;
                }
                
                data.push({
                    district: districts - manipulations + location,
                    votePercentage: votePercentage,
                    type: 'Manipulated'
                });
            }
            
            return data;
        }
        
        // Draw Russian tail chart
        function drawRussianTailChart() {
            const data = russianTailSimulation.data;
            if (!data || data.length === 0) return;
            
            // For overlapping mode, combine manipulated with rural
            const dataForOverlapping = russianTailSimulation.displayMode === 'overlapping' 
                ? data.map(d => ({
                    ...d,
                    type: d.type === 'Manipulated' ? 'Rural' : d.type
                  }))
                : data;
            
            const marks = russianTailSimulation.displayMode === 'stacked' 
                ? [
                    Plot.rectY(data, Plot.binX({y: "count"}, {
                        x: "votePercentage",
                        fill: "type",
                        mixBlendMode: "normal",
                        thresholds: 50
                    })),
                    Plot.ruleY([0])
                  ]
                : [
                    Plot.rectY(dataForOverlapping.filter(d => d.type === 'Urban'), Plot.binX({y2: "count"}, {
                        x: "votePercentage",
                        fill: "#3498db",
                        fillOpacity: 0.5,
                        thresholds: 50
                    })),
                    Plot.rectY(dataForOverlapping.filter(d => d.type === 'Rural'), Plot.binX({y2: "count"}, {
                        x: "votePercentage",
                        fill: "#27ae60",
                        fillOpacity: 0.5,
                        thresholds: 50
                    })),
                    Plot.ruleY([0])
                  ];
            
            const chart = Plot.plot({
                width: 900,
                height: 500,
                marginLeft: 50, 
                marginRight: 100, 
                marginTop: 20, 
                marginBottom: 50,
                x: {
                    label: "Vote Percentage for Candidate →",
                    domain: [0, 100]
                },
                y: {
                    label: "↑ Number of Districts"
                },
                color: russianTailSimulation.displayMode === 'stacked' ? {
                    legend: true,
                    domain: ["Urban", "Rural", "Manipulated"],
                    range: ["#3498db", "#27ae60", "#e74c3c"]
                } : undefined,
                marks: marks
            });
            
            // Add legend and annotation for overlapping mode
            if (russianTailSimulation.displayMode === 'overlapping') {
                const legendData = [
                    {x: 780, y: 30, label: "Urban", color: "#3498db"},
                    {x: 780, y: 50, label: "Rural + Manipulated", color: "#27ae60"}
                ];
                
                const annotationMarks = russianTailSimulation.manipulationLevel > 0 ? [
                    Plot.rect([{x1: 80, x2: 100, y1: 0, y2: 100}], {
                        x1: "x1",
                        x2: "x2", 
                        y1: "y1",
                        y2: "y2",
                        fill: "#e74c3c",
                        fillOpacity: 0.1
                    }),
                    Plot.text([{x: 90, y: 80, text: "Russian Tail"}], {
                        x: "x",
                        y: "y",
                        text: "text",
                        fill: "#e74c3c",
                        fontSize: 14,
                        fontWeight: "bold",
                        textAnchor: "middle"
                    })
                ] : [];
                
                const legendChart = Plot.plot({
                    width: 900,
                    height: 500,
                    marginLeft: 50, 
                    marginRight: 100, 
                    marginTop: 20, 
                    marginBottom: 50,
                    x: {
                        label: "Vote Percentage for Candidate →",
                        domain: [0, 100]
                    },
                    y: {
                        label: "↑ Number of Districts"
                    },
                    marks: [
                        ...annotationMarks,
                        ...marks,
                        Plot.dot(legendData, {
                            x: "x",
                            y: "y",
                            r: 6,
                            fill: "color"
                        }),
                        Plot.text(legendData, {
                            x: d => d.x + 15,
                            y: "y",
                            text: "label",
                            textAnchor: "start",
                            dy: 3
                        })
                    ]
                });
                
                document.getElementById('russianTailChart').replaceChildren(legendChart);
                return;
            }
            
            document.getElementById('russianTailChart').replaceChildren(chart);
        }
        
        // Event listeners
        document.getElementById('runSimulation').addEventListener('click', () => {
            simulation.data = generateElectionData();
            drawMainChart(simulation.data);
            drawHistogram(simulation.data);
        });
        
        // document.getElementById('runCoinFlip').addEventListener('click', runCoinFlipSimulation);
        document.getElementById('generateRussianTail').addEventListener('click', () => {
            russianTailSimulation.data = generateRussianTailData();
            drawRussianTailChart();
        });
        
        // Initial draw
        simulation.data = generateElectionData();
        drawMainChart(simulation.data);
        drawHistogram(simulation.data);
        runCoinFlipSimulation();
        russianTailSimulation.data = generateRussianTailData();
        drawRussianTailChart();
    </script>
</body>
</html>
